/* Generated By:JavaCC: Do not edit this line. TeXParser.java */
package parse;
import model.Element;
import model.Command;
import model.MacroDefinition;
import model.NewParagraph;
import model.NewLine;
import model.Group;
import model.Text;
import model.Marker;
import model.Option;
import model.Document;
import model.Whitespace;
import java.util.Arrays;
import java.util.Stack;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.HashMap;
import java.util.LinkedList;
import java.lang.Integer;

/** * Class to parse any tex document. */
@SuppressWarnings("all")
public class TeXParser implements TeXParserConstants {
  /**   * Flag to toggle between debug modes.   */
  protected final boolean DEBUG = false;

  /**   * The parsed macro definitions.   */
  protected Map <String, Group> macros = new HashMap <String, Group>();

  /**   * The list of all scheduled characters on checking if a command name belongs   * to a macro defined command.    */
  protected LinkedList <Character> schedule = new LinkedList <Character> ();

  /**   * The lookahead string on checking if a command name belongs to a macro   * defined command.    */
  protected StringBuilder lookahead = new StringBuilder();

  // ___________________________________________________________________________
  protected boolean belongsToMacroDefinedCommandName() {
    log("Token: " + getToken(1));

    if (!schedule.isEmpty()) {
      log("  Schedule is not empty: " + schedule);
      // There are scheduled characters. Check, if the current token satisfy the      // schedule.      if (satisfySchedule(getToken(1))) {
        log("  Token satisfies the schedule. Return true.");
        return true;
      } else {
        resetLookahead();
      }
    }

    int i = 1;
    boolean onlyLettersOrDigits = true;
    while (true) {
      Token token = getToken(i);
      if (isValidToken(token)) {
        char [] tokenChars = toCharArray(token);
        for (int j = 0; j < tokenChars.length; j++) {
          char tokenChar = tokenChars[j];

          // Append the token char to the current lookahead.          lookahead.append(tokenChar);

          log("  Lookahead query: " + lookahead);

          // Don't consider the first token char (which must be the identifier).          if (lookahead.length() > 1) {
            boolean isLetterOrDigit = Character.isLetterOrDigit(tokenChar);
            onlyLettersOrDigits = onlyLettersOrDigits && isLetterOrDigit;
          }

          // Check if there are macro definitions, that starts with the current          // lookahead string.          int numPrefixes = getNumberOfMacrosWithPrefix(lookahead.toString());
          // Continue, if there is at least one such macro definition.          log("  numPrefixes: " + numPrefixes);
          if (numPrefixes > 0) {
            continue;
          }

          // Check if there are macro definitions, that are equal to the current          // lookahead string.          int numMatches = getNumberOfMacrosMatches(lookahead.toString());
          log("  numMatches: " + numMatches);
          if (numMatches > 0) {
            // Check, if the next token is a character or digit.            char nextTokenChar = getNextTokenChar(i, j);
            boolean isLetterOrDigit = Character.isLetterOrDigit(nextTokenChar);
            if (onlyLettersOrDigits && isLetterOrDigit) {
              resetLookahead();
              return false;
            }

            schedule.clear();

            // Create a new schedule: Schedule all following token (except the            // current one).            for (int k = getToken(1).image.length(); k < lookahead.length(); k++) {
              schedule.add(lookahead.charAt(k));
            }
            log("  new schedule: " + schedule);
            return true;
          }
          resetLookahead();
          return false;
        }
      } else {
        resetLookahead();
        return false;
      }
      i++;
    }
  }

  /**   * Prints the given message to System.out if and only if DEBUG == true.    */
  protected void log(String log) {
    if (DEBUG) System.out.println(log);
  }

  /**   * Registers the given macro definition.   */
  protected void registerMacroDefinition(MacroDefinition macro) {
    macros.put(macro.getGroup().getText(), macro.getGroup(2));
  }

  /**   * Transforms the given token to char array.   */
  protected char [] toCharArray(Token token) {
    return token.image.toCharArray();
  }

  /**   * Returns true, if the given token corresponds to the current schedule.   */
  protected boolean satisfySchedule(Token token) {
    char [] tokenChars = toCharArray(token);
    boolean satisfy = true;
    for (char tokenChar : tokenChars) {
      if (tokenChar != schedule.pop()) {
        satisfy = false;
        break;
      }
    }
    return satisfy;
  }

  /**   * Returns true, if the given token is valid (the token is not null and the   * image of the token is not empty).   */
  protected boolean isValidToken(Token token) {
    return token != null && token.image != null && !token.image.equals("");
  }

  /**   * Returns the next character.   */
  protected char getNextTokenChar(int currentTokenIndex, int currentCharIndex) {
    // Check, if there are still unvisited characters in the current token.    Token currentToken = getToken(currentTokenIndex);
    if (isValidToken(currentToken)) {
      char [] tokenChars = toCharArray(currentToken);
      if (currentCharIndex < tokenChars.length - 1) {
        return tokenChars[currentCharIndex + 1];
      }
    }
    // Check, if there is a next token.    Token nextToken = getToken(currentTokenIndex + 1);
    if (isValidToken(nextToken)) {
      char [] tokenChars = toCharArray(nextToken);
      if (tokenChars.length > 0) {
        return tokenChars[0];
      }
    }
    return 0;
  }

  /**   * Resets the current lookahead.   */
  protected void resetLookahead() {
    lookahead.setLength(0);
    schedule.clear();
  }

  /**   * Computes the number of macros that start with the given prefix.   */
  protected int getNumberOfMacrosWithPrefix(String prefix) {
    int num = 0;
    for (String macro : macros.keySet()) {
      if (macro.startsWith(prefix) && !macro.equals(prefix)) {
        num++;
      }
    }
    return num;
  }

  /**   * Computes the number of macros that are equal to the given string   */
  protected int getNumberOfMacrosMatches(String prefix) {
    int num = 0;
    for (String macro : macros.keySet()) {
      if (macro.equals(prefix)) {
        num++;
      }
    }
    return num;
  }

  final public Document parse() throws ParseException {
  Document document = new Document();
    Document(document);
    jj_consume_token(0);
    {if (true) return document;}
    throw new Error("Missing return statement in function");
  }

  final protected void Document(Group context) throws ParseException {
  Token token;
    label_1:
    while (true) {
      if (jj_2_1(1)) {
        ;
      } else {
        break label_1;
      }
      if (jj_2_2(1)) {
        Element(context);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GROUP_END:
        case OPTION_END:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case GROUP_END:
            token = jj_consume_token(GROUP_END);
            break;
          case OPTION_END:
            token = jj_consume_token(OPTION_END);
            break;
          default:
            jj_la1[0] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        context.addElement(new Text(token.image));
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final protected void Element(Group context) throws ParseException {
  Element element;
    if (jj_2_3(2147483647)) {
      element = PotentialGroup();
    } else if (jj_2_4(2147483647)) {
      element = PotentialOption();
    } else if (jj_2_5(2147483647)) {
      element = Command();
    } else if (jj_2_6(2147483647)) {
      element = Text();
    } else if (jj_2_7(2147483647)) {
      element = NewParagraph();
    } else if (jj_2_8(2147483647)) {
      element = Newline();
    } else if (jj_2_9(2147483647)) {
      element = Whitespace();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MARKER:
        element = Marker();
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    context.addElement(element);
  }

  final protected Command Command() throws ParseException {
  Command command = null;
    if (jj_2_10(2147483647)) {
      command = MacroDefinition();
      registerMacroDefinition((MacroDefinition) command);
    } else if (jj_2_11(2147483647)) {
      command = MacroDefinedCommand();
    } else if (jj_2_12(2147483647)) {
      command = EscapeCommand();
    } else if (jj_2_13(2147483647)) {
      command = UsualCommand();
    } else if (jj_2_14(2147483647)) {
      command = WellDefinedCommand();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return command;}
    throw new Error("Missing return statement in function");
  }

  final protected MacroDefinition MacroDefinition() throws ParseException {
  MacroDefinition definition;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEF_COMMAND_PREFIX:
      definition = DefCommand();
      break;
    case NEW_COMMAND_PREFIX:
      definition = NewCommandCommand();
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return definition;}
    throw new Error("Missing return statement in function");
  }

  final protected MacroDefinition DefCommand() throws ParseException {
  MacroDefinition definition;
  Token identifier;
  Command macroCommand;
  Group macroGroup;
    // Find the identifier ("\def").
      identifier = jj_consume_token(DEF_COMMAND_PREFIX);
    definition = new MacroDefinition(identifier.image);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
      case NEW_LINE:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      case NEW_LINE:
        jj_consume_token(NEW_LINE);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BEGIN_TABBING:
    case END_TABBING:
    case COMMAND_PREFIX:
    case DEF_COMMAND_PREFIX:
    case WELL_DEFINED_DEFAULT_COMMAND:
    case WELL_DEFINED_TABBING_COMMAND:
    case WELL_DEFINED_COMMON_COMMAND:
    case ESCAPE_COMMAND_DEFAULT_NAME:
    case ESCAPE_COMMAND_TABBING_NAME:
    case ESCAPE_COMMAND_COMMON_NAME:
      // The macro may be given as a command ...  
          macroCommand = MacroCommand();
      definition.addGroup(new Group(macroCommand));
      break;
    case GROUP_START:
      jj_consume_token(GROUP_START);
      // The macro may be given as a command ...  
            macroCommand = MacroCommand();
        definition.addGroup(new Group(macroCommand));
      jj_consume_token(GROUP_END);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MARKER:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_3;
      }
      Marker();
    }
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        ;
        break;
      default:
        jj_la1[8] = jj_gen;
        break label_4;
      }
      jj_consume_token(WHITESPACE);
    }
    // Find the group of the macro (including the arguments).
      macroGroup = Group();
    definition.addGroup(macroGroup);
    {if (true) return definition;}
    throw new Error("Missing return statement in function");
  }

  final protected MacroDefinition NewCommandCommand() throws ParseException {
  MacroDefinition definition;
  Token identifier;
  Command macroCommand;
  Group macroGroup;
  Group macro2ndGroup;
    identifier = jj_consume_token(NEW_COMMAND_PREFIX);
    definition = new MacroDefinition(identifier.image);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
      case NEW_LINE:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      case NEW_LINE:
        jj_consume_token(NEW_LINE);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BEGIN_TABBING:
    case END_TABBING:
    case COMMAND_PREFIX:
    case DEF_COMMAND_PREFIX:
    case WELL_DEFINED_DEFAULT_COMMAND:
    case WELL_DEFINED_TABBING_COMMAND:
    case WELL_DEFINED_COMMON_COMMAND:
    case ESCAPE_COMMAND_DEFAULT_NAME:
    case ESCAPE_COMMAND_TABBING_NAME:
    case ESCAPE_COMMAND_COMMON_NAME:
      // The macro may be given as a command ...  
          macroCommand = MacroCommand();
      definition.addGroup(new Group(macroCommand));
      break;
    case GROUP_START:
      // ... or a group.
          macroGroup = Group();
      definition.addGroup(macroGroup);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
      case NEW_LINE:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_6;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        jj_consume_token(WHITESPACE);
        break;
      case NEW_LINE:
        jj_consume_token(NEW_LINE);
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    label_7:
    while (true) {
      if (jj_2_15(2147483647)) {
        ;
      } else {
        break label_7;
      }
      Option();
    }
    // Find the second group, including the arguments of the macro.
      macro2ndGroup = Group();
    definition.addGroup(macro2ndGroup);
    {if (true) return definition;}
    throw new Error("Missing return statement in function");
  }

  final protected Command MacroCommand() throws ParseException {
  Token commandName;
    // Find the command name.
      commandName = MacroCommandName();
    {if (true) return new Command(commandName.image);}
    throw new Error("Missing return statement in function");
  }

  final protected Token MacroCommandName() throws ParseException {
  StringBuilder commandName = new StringBuilder();
  Token identifier;
  Token symbol;
    // Find the identifier (usually just "\")
      identifier = MacroCommandIdentifier();
    commandName.append(identifier.image);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DIGIT:
      case CHAR:
      case OTHER_SYMBOL:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_8;
      }
      symbol = MacroCommandSymbol();
      commandName.append(symbol.image);
    }
    {if (true) return new Token(-2, commandName.toString());}
    throw new Error("Missing return statement in function");
  }

  final protected Token MacroCommandIdentifier() throws ParseException {
  Token identifier;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMAND_PREFIX:
      identifier = UsualCommandIdentifier();
      break;
    case BEGIN_TABBING:
    case END_TABBING:
    case WELL_DEFINED_DEFAULT_COMMAND:
    case WELL_DEFINED_TABBING_COMMAND:
    case WELL_DEFINED_COMMON_COMMAND:
      identifier = WellDefinedCommandName();
      break;
    case ESCAPE_COMMAND_DEFAULT_NAME:
    case ESCAPE_COMMAND_TABBING_NAME:
    case ESCAPE_COMMAND_COMMON_NAME:
      identifier = EscapeCommandName();
      break;
    case DEF_COMMAND_PREFIX:
      identifier = jj_consume_token(DEF_COMMAND_PREFIX);
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return identifier;}
    throw new Error("Missing return statement in function");
  }

  final protected Token MacroCommandSymbol() throws ParseException {
  Token symbol;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHAR:
      symbol = jj_consume_token(CHAR);
      break;
    case DIGIT:
      symbol = jj_consume_token(DIGIT);
      break;
    case OTHER_SYMBOL:
      symbol = jj_consume_token(OTHER_SYMBOL);
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return symbol;}
    throw new Error("Missing return statement in function");
  }

  final protected Command MacroDefinedCommand() throws ParseException {
  Command command;
  Token commandName;
  Group group;
    commandName = MacroDefinedCommandName();
    command = new Command(commandName.image);
    if (jj_2_16(2147483647)) {
      Option();
    } else {
      ;
    }
    label_9:
    while (true) {
      if (jj_2_17(2147483647)) {
        ;
      } else {
        break label_9;
      }
      group = Group();
      command.addGroup(group);
    }
    {if (true) return command;}
    throw new Error("Missing return statement in function");
  }

  final protected Token MacroDefinedCommandName() throws ParseException {
  StringBuilder commandName = new StringBuilder();
  Token identifier;
  Token symbol;
    if (belongsToMacroDefinedCommandName()) {

    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    identifier = MacroCommandIdentifier();
    log("CONSUME IDENTIFIER: " + identifier);
    commandName.append(identifier.image);
    label_10:
    while (true) {
      if (belongsToMacroDefinedCommandName()) {
        ;
      } else {
        break label_10;
      }
      symbol = MacroCommandSymbol();
      log("CONSUME TOKEN: " + symbol);
      commandName.append(symbol.image);
    }
    {if (true) return new Token(- 2, commandName.toString());}
    throw new Error("Missing return statement in function");
  }

  final protected Command UsualCommand() throws ParseException {
  Command command;
  Token commandName;
  Group group;
  Option option;
    commandName = UsualCommandName();
    command = new Command(commandName.image);
    if (jj_2_18(2147483647)) {
      Option();
    } else {
      ;
    }
    label_11:
    while (true) {
      if (jj_2_19(2147483647)) {
        ;
      } else {
        break label_11;
      }
      group = Group();
      command.addGroup(group);
    }
    {if (true) return command;}
    throw new Error("Missing return statement in function");
  }

  final protected Token UsualCommandName() throws ParseException {
  StringBuilder commandName = new StringBuilder();
  Token identifier;
  Token symbol;
    identifier = UsualCommandIdentifier();
    commandName.append(identifier.image);
    label_12:
    while (true) {
      symbol = UsualCommandSymbol();
      commandName.append(symbol.image);
      if (jj_2_20(2147483647)) {
        ;
      } else {
        break label_12;
      }
    }
    if (jj_2_21(2147483647)) {
      symbol = jj_consume_token(STAR);
     commandName.append(symbol.image);
    } else {
      ;
    }
    {if (true) return new Token(- 2, commandName.toString());}
    throw new Error("Missing return statement in function");
  }

  final protected Token UsualCommandIdentifier() throws ParseException {
  Token token;
    token = jj_consume_token(COMMAND_PREFIX);
    {if (true) return token;}
    throw new Error("Missing return statement in function");
  }

  final protected Token UsualCommandSymbol() throws ParseException {
  Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHAR:
      token = jj_consume_token(CHAR);
      break;
    case DIGIT:
      token = jj_consume_token(DIGIT);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return token;}
    throw new Error("Missing return statement in function");
  }

  final protected Command WellDefinedCommand() throws ParseException {
  Token commandName;
    commandName = WellDefinedCommandName();
    {if (true) return new Command(commandName.image);}
    throw new Error("Missing return statement in function");
  }

  final protected Token WellDefinedCommandName() throws ParseException {
  Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WELL_DEFINED_DEFAULT_COMMAND:
      token = jj_consume_token(WELL_DEFINED_DEFAULT_COMMAND);
      break;
    case WELL_DEFINED_TABBING_COMMAND:
      token = jj_consume_token(WELL_DEFINED_TABBING_COMMAND);
      break;
    case WELL_DEFINED_COMMON_COMMAND:
      token = jj_consume_token(WELL_DEFINED_COMMON_COMMAND);
      break;
    case BEGIN_TABBING:
      token = jj_consume_token(BEGIN_TABBING);
      break;
    case END_TABBING:
      token = jj_consume_token(END_TABBING);
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return token;}
    throw new Error("Missing return statement in function");
  }

  final protected Command EscapeCommand() throws ParseException {
  Token commandName;
  Command command;
  Group group;
  Token symbol;
  Token arg;
    commandName = EscapeCommandName();
    command = new Command(commandName.image);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WHITESPACE:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_13;
      }
      jj_consume_token(WHITESPACE);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GROUP_START:
      group = Group();
      break;
    case DIGIT:
    case CHAR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHAR:
        symbol = jj_consume_token(CHAR);
        break;
      case DIGIT:
        symbol = jj_consume_token(DIGIT);
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      group = new Group(new Text(symbol.image));
      break;
    case COMMAND_PREFIX:
      // Allow the command \'\i.
          arg = UsualCommandName();
      group = new Group(new Command(arg.image));
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    command.addGroup(group);
    {if (true) return command;}
    throw new Error("Missing return statement in function");
  }

  final protected Token EscapeCommandName() throws ParseException {
  Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ESCAPE_COMMAND_DEFAULT_NAME:
      token = jj_consume_token(ESCAPE_COMMAND_DEFAULT_NAME);
      break;
    case ESCAPE_COMMAND_COMMON_NAME:
      token = jj_consume_token(ESCAPE_COMMAND_COMMON_NAME);
      break;
    case ESCAPE_COMMAND_TABBING_NAME:
      token = jj_consume_token(ESCAPE_COMMAND_TABBING_NAME);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return token;}
    throw new Error("Missing return statement in function");
  }

  final protected Text Text() throws ParseException {
  StringBuilder text = new StringBuilder();
  Token symbol;
    label_14:
    while (true) {
      symbol = TextSymbol();
      text.append(symbol.image);
      if (jj_2_22(2147483647)) {
        ;
      } else {
        break label_14;
      }
    }
    {if (true) return new Text(text.toString());}
    throw new Error("Missing return statement in function");
  }

  final protected Token TextSymbol() throws ParseException {
  Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHAR:
      token = jj_consume_token(CHAR);
      break;
    case DIGIT:
      token = jj_consume_token(DIGIT);
      break;
    case STAR:
      token = jj_consume_token(STAR);
      break;
    case OTHER_SYMBOL:
      token = jj_consume_token(OTHER_SYMBOL);
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return token;}
    throw new Error("Missing return statement in function");
  }

  final protected Element PotentialGroup() throws ParseException {
  Group group;
  Token token;
    if (jj_2_23(2147483647)) {
      group = Group();
    {if (true) return group;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GROUP_START:
        token = jj_consume_token(GROUP_START);
    {if (true) return new Text(token.image);}
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final protected Group Group() throws ParseException {
  Group group = new Group();
  Token optionEnd;
    jj_consume_token(GROUP_START);
    label_15:
    while (true) {
      if (jj_2_24(1)) {
        ;
      } else {
        break label_15;
      }
      if (jj_2_25(2147483647)) {
        Element(group);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPTION_END:
          optionEnd = jj_consume_token(OPTION_END);
      group.addElement(new Text(optionEnd.image));
          break;
        default:
          jj_la1[25] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    jj_consume_token(GROUP_END);
    {if (true) return group;}
    throw new Error("Missing return statement in function");
  }

  final protected Element PotentialOption() throws ParseException {
  Option option;
  Token token;
    if (jj_2_26(2147483647)) {
      option = Option();
    {if (true) return option;}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPTION_START:
        token = jj_consume_token(OPTION_START);
    {if (true) return new Text(token.image);}
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  final protected Option Option() throws ParseException {
  Option option = new Option();
  Token groupEnd;
    jj_consume_token(OPTION_START);
    label_16:
    while (true) {
      if (jj_2_27(1)) {
        ;
      } else {
        break label_16;
      }
      if (jj_2_28(2147483647)) {
        Element(option);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GROUP_END:
          groupEnd = jj_consume_token(GROUP_END);
      option.addElement(new Text(groupEnd.image));
          break;
        default:
          jj_la1[27] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    jj_consume_token(OPTION_END);
    {if (true) return option;}
    throw new Error("Missing return statement in function");
  }

  final protected Marker Marker() throws ParseException {
  Token token;
    token = jj_consume_token(MARKER);
    {if (true) return new Marker(Integer.parseInt(token.image.substring(1)));}
    throw new Error("Missing return statement in function");
  }

  final protected NewParagraph NewParagraph() throws ParseException {
  Token token;
    token = jj_consume_token(NEW_PARAGRAPH);
    {if (true) return new NewParagraph();}
    throw new Error("Missing return statement in function");
  }

  final protected NewLine Newline() throws ParseException {
  Token token;
    token = jj_consume_token(NEW_LINE);
    {if (true) return new NewLine();}
    throw new Error("Missing return statement in function");
  }

  final protected Whitespace Whitespace() throws ParseException {
  Token token;
    token = jj_consume_token(WHITESPACE);
    {if (true) return new Whitespace();}
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_3_17() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_3R_66()) return true;
    return false;
  }

  private boolean jj_3_16() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_24() {
    if (jj_scan_token(NEW_LINE)) return true;
    return false;
  }

  private boolean jj_3R_58() {
    if (jj_3R_72()) return true;
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_3R_71()) return true;
    return false;
  }

  private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) return true;
    }
    return false;
  }

  private boolean jj_3R_26() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_63() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_27() {
    if (jj_3R_59()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_61()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_23() {
    if (jj_scan_token(NEW_PARAGRAPH)) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3R_28() {
    if (jj_3R_62()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(6)) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_12() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_3R_29()) return true;
    return false;
  }

  private boolean jj_3_10() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_scan_token(MARKER)) return true;
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_3R_28()) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_3R_27()) return true;
    return false;
  }

  private boolean jj_3R_91() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_3R_26()) return true;
    return false;
  }

  private boolean jj_3_28() {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_69() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(17)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(4)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) return true;
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_38() {
    if (jj_scan_token(GROUP_END)) return true;
    return false;
  }

  private boolean jj_3R_90() {
    if (jj_3R_62()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) return true;
    }
    return false;
  }

  private boolean jj_3R_37() {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_88() {
    if (jj_3R_76()) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3R_74() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_31() {
    if (jj_scan_token(OPTION_START)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_27()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(OPTION_END)) return true;
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    if (jj_3R_70()) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_30() {
    if (jj_3R_69()) return true;
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_3R_25()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3_26() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_3R_24()) return true;
    return false;
  }

  private boolean jj_3_4() {
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_3R_23()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_scan_token(OPTION_START)) return true;
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_3R_91()) return true;
    return false;
  }

  private boolean jj_3_3() {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_42() {
    if (jj_3R_22()) return true;
    return false;
  }

  private boolean jj_3R_41() {
    if (jj_3R_21()) return true;
    return false;
  }

  private boolean jj_3R_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    }
    return false;
  }

  private boolean jj_3R_49() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_93() {
    if (jj_3R_74()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_94()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_3R_20()) return true;
    return false;
  }

  private boolean jj_3R_39() {
    if (jj_3R_19()) return true;
    return false;
  }

  private boolean jj_3R_33() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) return true;
    }
    return false;
  }

  private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3_25() {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3R_92() {
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_scan_token(OPTION_END)) return true;
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_scan_token(COMMAND_PREFIX)) return true;
    return false;
  }

  private boolean jj_3_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) {
    jj_scanpos = xsp;
    if (jj_3R_36()) return true;
    }
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3_21() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_scan_token(GROUP_START)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_24()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(GROUP_END)) return true;
    return false;
  }

  private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(11)) {
    jj_scanpos = xsp;
    if (jj_scan_token(13)) return true;
    }
    return false;
  }

  private boolean jj_3_20() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_3R_18()) return true;
    return false;
  }

  private boolean jj_3_1() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_2()) {
    jj_scanpos = xsp;
    if (jj_3R_17()) return true;
    }
    return false;
  }

  private boolean jj_3_23() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_87() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    if (jj_scan_token(GROUP_START)) return true;
    return false;
  }

  private boolean jj_3R_86() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(6)) {
    jj_scanpos = xsp;
    if (jj_scan_token(7)) return true;
    }
    return false;
  }

  private boolean jj_3R_85() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) return true;
    }
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_84() {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_3R_76()) return true;
    Token xsp;
    if (jj_3R_77()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_77()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_78()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_83() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(6)) {
    jj_scanpos = xsp;
    if (jj_scan_token(7)) return true;
    }
    return false;
  }

  private boolean jj_3_19() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_scan_token(NEW_COMMAND_PREFIX)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_83()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_86()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_87()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(9)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_67() {
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_29() {
    if (jj_3R_66()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_68()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_3R_70()) return true;
    return false;
  }

  private boolean jj_3R_22() {
    Token xsp;
    if (jj_3R_56()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_56()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_81() {
    if (jj_scan_token(GROUP_START)) return true;
    if (jj_3R_92()) return true;
    if (jj_scan_token(GROUP_END)) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_3R_92()) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_3R_91()) return true;
    return false;
  }

  private boolean jj_3R_79() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(6)) {
    jj_scanpos = xsp;
    if (jj_scan_token(7)) return true;
    }
    return false;
  }

  private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(20)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_73() {
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_scan_token(DEF_COMMAND_PREFIX)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_79()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_80()) {
    jj_scanpos = xsp;
    if (jj_3R_81()) return true;
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_82()) { jj_scanpos = xsp; break; }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(6)) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_32()) return true;
    return false;
  }

  private boolean jj_3R_25() {
    if (jj_scan_token(WHITESPACE)) return true;
    return false;
  }

  private boolean jj_3R_59() {
    jj_lookingAhead = true;
    jj_semLA = belongsToMacroDefinedCommandName();
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_73()) return true;
    if (jj_3R_74()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_75()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  /** Generated Token Manager. */
  public TeXParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[28];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x2800,0x2800,0x800000,0x18000,0xc0,0xc0,0x7ec430,0x800000,0x40,0xc0,0xc0,0x7ec430,0xc0,0xc0,0x1c000000,0x7ec030,0x1c000000,0xc000000,0xe0030,0x40,0xc000000,0xc004400,0x700000,0x1c000200,0x400,0x2000,0x1000,0x800,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[28];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public TeXParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public TeXParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TeXParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public TeXParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TeXParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public TeXParser(TeXParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(TeXParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 28; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[29];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 28; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 29; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 28; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
