options{  STATIC = false;  DEBUG_PARSER = false;  DEBUG_LOOKAHEAD = false;  DEBUG_TOKEN_MANAGER = false;}PARSER_BEGIN(TeXParser)package parse;import model.Element;import model.Command;import model.MacroDefinition;import model.NewParagraph;import model.NewLine;import model.Group;import model.Text;import model.Marker;import model.Option;import model.Document;import model.Whitespace;import java.util.Arrays;import java.util.Stack;import java.util.Map;import java.util.Set;import java.util.HashSet;import java.util.HashMap;import java.util.LinkedList;import java.lang.Integer;/** * Class to parse any tex document. */public class TeXParser {  /**   * Flag to toggle between debug modes.   */  protected final boolean DEBUG = false;  /**   * The parsed macro definitions.   */  protected Map <String, Group> macros = new HashMap <String, Group>();  /**   * The list of all scheduled characters on checking if a command name belongs   * to a macro defined command.    */  protected LinkedList <Character> schedule = new LinkedList <Character> ();  /**   * The lookahead string on checking if a command name belongs to a macro   * defined command.    */  protected StringBuilder lookahead = new StringBuilder();  // ___________________________________________________________________________  protected boolean belongsToMacroDefinedCommandName() {    log("Token: " + getToken(1));        if (!schedule.isEmpty()) {      log("  Schedule is not empty: " + schedule);      // There are scheduled characters. Check, if the current token satisfy the      // schedule.      if (satisfySchedule(getToken(1))) {        log("  Token satisfies the schedule. Return true.");        return true;      } else {        resetLookahead();      }    }    int i = 1;    boolean onlyLettersOrDigits = true;    while (true) {      Token token = getToken(i);      if (isValidToken(token)) {        char [] tokenChars = toCharArray(token);        for (int j = 0; j < tokenChars.length; j++) {          char tokenChar = tokenChars[j];                    // Append the token char to the current lookahead.          lookahead.append(tokenChar);          log("  Lookahead query: " + lookahead);          // Don't consider the first token char (which must be the identifier).          if (lookahead.length() > 1) {            boolean isLetterOrDigit = Character.isLetterOrDigit(tokenChar);            onlyLettersOrDigits = onlyLettersOrDigits && isLetterOrDigit;          }                    // Check if there are macro definitions, that starts with the current          // lookahead string.          int numPrefixes = getNumberOfMacrosWithPrefix(lookahead.toString());          // Continue, if there is at least one such macro definition.          log("  numPrefixes: " + numPrefixes);          if (numPrefixes > 0) {            continue;          }                    // Check if there are macro definitions, that are equal to the current          // lookahead string.          int numMatches = getNumberOfMacrosMatches(lookahead.toString());          log("  numMatches: " + numMatches);          if (numMatches > 0) {            // Check, if the next token is a character or digit.            char nextTokenChar = getNextTokenChar(i, j);            boolean isLetterOrDigit = Character.isLetterOrDigit(nextTokenChar);            if (onlyLettersOrDigits && isLetterOrDigit) {              resetLookahead();              return false;            }            schedule.clear();                        // Create a new schedule: Schedule all following token (except the            // current one).            for (int k = getToken(1).image.length(); k < lookahead.length(); k++) {              schedule.add(lookahead.charAt(k));            }            log("  new schedule: " + schedule);            return true;          }          resetLookahead();          return false;        }      } else {        resetLookahead();        return false;      }      i++;    }  }  /**   * Prints the given message to System.out if and only if DEBUG == true.    */  protected void log(String log) {    if (DEBUG) System.out.println(log);  }  /**   * Registers the given macro definition.   */  protected void registerMacroDefinition(MacroDefinition macro) {    macros.put(macro.getGroup().getText(), macro.getGroup(2));  }  /**   * Transforms the given token to char array.   */  protected char [] toCharArray(Token token) {    return token.image.toCharArray();  }  /**   * Returns true, if the given token corresponds to the current schedule.   */  protected boolean satisfySchedule(Token token) {    char [] tokenChars = toCharArray(token);    boolean satisfy = true;    for (char tokenChar : tokenChars) {      if (tokenChar != schedule.pop()) {        satisfy = false;        break;      }    }    return satisfy;  }  /**   * Returns true, if the given token is valid (the token is not null and the   * image of the token is not empty).   */  protected boolean isValidToken(Token token) {    return token != null && token.image != null && !token.image.equals("");  }  /**   * Returns the next character.   */  protected char getNextTokenChar(int currentTokenIndex, int currentCharIndex) {    // Check, if there are still unvisited characters in the current token.    Token currentToken = getToken(currentTokenIndex);    if (isValidToken(currentToken)) {      char [] tokenChars = toCharArray(currentToken);      if (currentCharIndex < tokenChars.length - 1) {        return tokenChars[currentCharIndex + 1];      }    }    // Check, if there is a next token.    Token nextToken = getToken(currentTokenIndex + 1);    if (isValidToken(nextToken)) {      char [] tokenChars = toCharArray(nextToken);      if (tokenChars.length > 0) {        return tokenChars[0];      }    }    return 0;  }  /**   * Resets the current lookahead.   */  protected void resetLookahead() {    lookahead.setLength(0);    schedule.clear();  }  /**   * Computes the number of macros that start with the given prefix.   */  protected int getNumberOfMacrosWithPrefix(String prefix) {    int num = 0;    for (String macro : macros.keySet()) {      if (macro.startsWith(prefix) && !macro.equals(prefix)) {        num++;      }    }    return num;  }  /**   * Computes the number of macros that are equal to the given string   */  protected int getNumberOfMacrosMatches(String prefix) {    int num = 0;    for (String macro : macros.keySet()) {      if (macro.equals(prefix)) {        num++;      }    }    return num;  }}PARSER_END(TeXParser)// =============================================================================/** * The entry point to this parser. */public Document parse() :{  Document document = new Document();}{  Document(document) < EOF >  {    return document;  }}/** * Tries to identify a document in the given context. */protected void Document(Group context) :{  Token token;}{  (    Element(context)  |    (      (        token = < GROUP_END >      | token = < OPTION_END >      )      {        context.addElement(new Text(token.image));      }    )  )*}/** * Tries to identify a common element. That could be (a) a comment, (b) a group, * (c) an option, (d) a command, (e) a text, (f) a marker, (g) a new paragraph * or (h) a new line. */protected void Element(Group context) :{  Element element;}{  (    LOOKAHEAD(PotentialGroup())    element = PotentialGroup()    |     LOOKAHEAD(PotentialOption())    element = PotentialOption()    |     LOOKAHEAD(Command())    element = Command()    |     LOOKAHEAD(Text())    element = Text()    |    LOOKAHEAD(NewParagraph())    element = NewParagraph()    |     LOOKAHEAD(Newline())    element = Newline()    |     LOOKAHEAD(Whitespace())    element = Whitespace()    |     element = Marker()  )  {    context.addElement(element);  }}// _____________________________________________________________________________// Parse Commands./** * Tries to identify a command. */protected Command Command() :{  Command command = null;}{  (    LOOKAHEAD(MacroDefinition())    command = MacroDefinition()    {      registerMacroDefinition((MacroDefinition) command);    }  |     LOOKAHEAD(MacroDefinedCommand())    command = MacroDefinedCommand()  |     LOOKAHEAD(EscapeCommand())    command = EscapeCommand()  |     LOOKAHEAD(UsualCommand())    command = UsualCommand()  |     LOOKAHEAD(WellDefinedCommand())    command = WellDefinedCommand()  )  {    return command;  }}// _______________________// Parse macro definitions./** * Tries to identify a macro definition, that is a * \def or \newcommand (\renewcommand). */protected MacroDefinition MacroDefinition() :{  MacroDefinition definition;}{  (    definition = DefCommand()  | definition = NewCommandCommand()  )  {    return definition;  }}// ____________________// Parse \def commands./** * Tries to identify a \def command. Will find all command of the syntax * \def\foobar#1#2#3{xxx} */protected MacroDefinition DefCommand() :{  MacroDefinition definition;  Token identifier;  Command macroCommand;  Group macroGroup;}{  // Find the identifier ("\def").  identifier = < DEF_COMMAND_PREFIX >  { definition = new MacroDefinition(identifier.image); }  // Allow any whitespaces.  (<WHITESPACE> | <NEW_LINE>)*  (    // The macro may be given as a command ...      macroCommand = MacroCommand()    { definition.addGroup(new Group(macroCommand)); }    |    (      <GROUP_START>            // The macro may be given as a command ...        macroCommand = MacroCommand()      { definition.addGroup(new Group(macroCommand)); }      <GROUP_END>    )  )    // Find the markers #1#2...  (Marker())*  // Allow any whitespaces.  (<WHITESPACE>)*   // Find the group of the macro (including the arguments).  macroGroup = Group()  { definition.addGroup(macroGroup); }  { return definition; }}// ___________________________// Parse \newcommand commands.protected MacroDefinition NewCommandCommand() :{  MacroDefinition definition;  Token identifier;  Command macroCommand;  Group macroGroup;  Group macro2ndGroup;}{  identifier = < NEW_COMMAND_PREFIX >  { definition = new MacroDefinition(identifier.image); }  // Allow any whitespaces.  (<WHITESPACE> | <NEW_LINE>)*  // Find the name of the command to define, which may be wrapped in a group.  (    // The macro may be given as a command ...      macroCommand = MacroCommand()    { definition.addGroup(new Group(macroCommand)); }    |     // ... or a group.    macroGroup = Group()    { definition.addGroup(macroGroup); }  )    // Allow any whitespaces.  (<WHITESPACE> | <NEW_LINE>)*    // Find the options, if any.  (LOOKAHEAD(Option()) Option())*    // Find the second group, including the arguments of the macro.  macro2ndGroup = Group()  { definition.addGroup(macro2ndGroup); }  { return definition; }}/** * Tries to parse a macro command which is defined via a \def command. */protected Command MacroCommand() :{  Token commandName;}{  // Find the command name.  commandName = MacroCommandName()  {    return new Command(commandName.image);  }}protected Token MacroCommandName() :{  StringBuilder commandName = new StringBuilder();  Token identifier;  Token symbol;}{  // Find the identifier (usually just "\")  identifier = MacroCommandIdentifier()  {    commandName.append(identifier.image);  }  // Find the symbols of the command name.  (    symbol = MacroCommandSymbol()    {      commandName.append(symbol.image);    }  )*  {    return new Token(-2, commandName.toString());  }}protected Token MacroCommandIdentifier() :{  Token identifier;}{  (    identifier = UsualCommandIdentifier()  | identifier = WellDefinedCommandName()  | identifier = EscapeCommandName()  | identifier = < DEF_COMMAND_PREFIX >  )  {    return identifier;  }}/** * Tries to parse a symbol of the name of a command, which is defined via a * \def command. */protected Token MacroCommandSymbol() :{  Token symbol;}{  (    symbol = < CHAR >  | symbol = < DIGIT >  | symbol = < OTHER_SYMBOL >  )  {    return symbol;  }}// _________________________________________________________// Parse commands which were defined via a macro definition.protected Command MacroDefinedCommand() :{  Command command;  Token commandName;  Group group;}{  commandName = MacroDefinedCommandName()  {    command = new Command(commandName.image);  }  [    LOOKAHEAD(Option())    Option()  ]  (    LOOKAHEAD(Group())    group = Group()    {      command.addGroup(group);    }  )*  { return command; }}protected Token MacroDefinedCommandName() :{  StringBuilder commandName = new StringBuilder();  Token identifier;  Token symbol;}{  LOOKAHEAD({ belongsToMacroDefinedCommandName() })  identifier = MacroCommandIdentifier()  {    log("CONSUME IDENTIFIER: " + identifier);    commandName.append(identifier.image);  }//  LOOKAHEAD({ belongsToMacroDefinedCommandName() })//  symbol = MacroCommandSymbol()//  {//    log("CONSUME SYMBOL: " + symbol);//    commandName.append(symbol.image);//  }  (    LOOKAHEAD({ belongsToMacroDefinedCommandName() })    symbol = MacroCommandSymbol()    {      log("CONSUME TOKEN: " + symbol);      commandName.append(symbol.image);    }  )*  {    return new Token(- 2, commandName.toString());  }}// _____________________// Parse usual commands.protected Command UsualCommand() :{  Command command;  Token commandName;  Group group;  Option option;}{  commandName = UsualCommandName()  {    command = new Command(commandName.image);  }  [    LOOKAHEAD(Option())    Option()  ]  (    LOOKAHEAD((< WHITESPACE >)* Group())    (< WHITESPACE >)*    group = Group()    {      command.addGroup(group);    }  )*  {    return command;  }}protected Token UsualCommandName() :{  StringBuilder commandName = new StringBuilder();  Token identifier;  Token symbol;}{  identifier = UsualCommandIdentifier()  {    commandName.append(identifier.image);  }  (    LOOKAHEAD(UsualCommandSymbol())    symbol = UsualCommandSymbol()    {      commandName.append(symbol.image);    }  )+  // The command name is may be followed by a "*" (\section*)  [   LOOKAHEAD(<STAR>) symbol = < STAR >   { commandName.append(symbol.image); }  ]    {    return new Token(- 2, commandName.toString());  }}protected Token UsualCommandIdentifier() :{  Token token;}{  (    token = < COMMAND_PREFIX >  )  { return token; }}protected Token UsualCommandSymbol() :{  Token token;}{  (    token = < CHAR >  | token = < DIGIT >  | token = "=" // To identify commands like \epsfxsize=8cm  )  {    return token;  }}// ____________________________// Parse well defined commands./** * Tries to identify a well defined command, that is a command with a well-known * syntax and that are not a prefix of another command. Examples are: \\, \%, * \{, etc. */protected Command WellDefinedCommand() :{  Token commandName;}{  commandName = WellDefinedCommandName()  {    return new Command(commandName.image);  }}/** * Tries to parse the name of a well defined command. */protected Token WellDefinedCommandName() :{  Token token;}{  (    token = < WELL_DEFINED_DEFAULT_COMMAND >  | token = < WELL_DEFINED_TABBING_COMMAND >  | token = < WELL_DEFINED_COMMON_COMMAND >  | token = < BEGIN_TABBING >  | token = < END_TABBING >  )  {    return token;  }}// ______________________// Parse escape commands./** * Tries to identify an escape command, that is a command which escapes a * special character. The syntax may be: (a) \"a, \"{a}, etc.  */protected Command EscapeCommand() :{  Token commandName;  Command command;  Group group;  Token symbol;  Token arg;}{  commandName = EscapeCommandName()  {    command = new Command(commandName.image);  }  (< WHITESPACE >)*  (    group = Group()  |    (      symbol = < CHAR >    | symbol = < DIGIT >    )    {      group = new Group(new Text(symbol.image));    }  |     // Allow the command \'\i.    arg = UsualCommandName()    {      group = new Group(new Command(arg.image));    }  )  {    command.addGroup(group);  }  {    return command;  }}/** * Tries to parse the name of an escape command. */protected Token EscapeCommandName() :{  Token token;}{  (    token = < ESCAPE_COMMAND_DEFAULT_NAME >  | token = < ESCAPE_COMMAND_COMMON_NAME >  | token = < ESCAPE_COMMAND_TABBING_NAME >  )  {    return token;  }}// _____________________________________________________________________________// Parse text./** * Finds a text passage. */protected Text Text() :{  StringBuilder text = new StringBuilder();  Token symbol;}{  (    LOOKAHEAD(TextSymbol())    symbol = TextSymbol()    {      text.append(symbol.image);    }  )+  {    return new Text(text.toString());  }}protected Token TextSymbol() :{  Token token;}{  (    token = < CHAR >  | token = < DIGIT >  | token = < STAR >  | token = < OTHER_SYMBOL >  )  {    return token;  }}// _____________________________________________________________________________// Parse a group.protected Element PotentialGroup() :{  Group group;  Token token;}{  LOOKAHEAD(Group())  group = Group()  {    return group;  }|   token = < GROUP_START >  {    return new Text(token.image);  }}protected Group Group() :{  Group group = new Group();  Token optionEnd;}{  < GROUP_START >  (    LOOKAHEAD(Element(group))    Element(group)  | optionEnd = < OPTION_END >    {      group.addElement(new Text(optionEnd.image));    }  )*  < GROUP_END >  {    return group;  }}// _____________________________________________________________________________// Parse an option.protected Element PotentialOption() :{  Option option;  Token token;}{  LOOKAHEAD(Option())  option = Option()  {    return option;  }|   token = < OPTION_START >  {    return new Text(token.image);  }}protected Option Option() :{  Option option = new Option();  Token groupEnd;}{  < OPTION_START >  (    LOOKAHEAD(Element(option))    Element(option)  | groupEnd = < GROUP_END >    {      option.addElement(new Text(groupEnd.image));    }  )*  < OPTION_END >  {    return option;  }}// _____________________________________________________________________________/** * Finds a marker within a command, that is a placeholder like #1 in a macro. */protected Marker Marker() :{  Token token;}{  token = < MARKER >  {    return new Marker(Integer.parseInt(token.image.substring(1)));  }}/** * Finds new paragraphs. */protected NewParagraph NewParagraph() :{  Token token;}{  (    token = < NEW_PARAGRAPH >  )  {    return new NewParagraph();  }}/** * Finds newlines. */protected NewLine Newline() :{  Token token;}{  (    token = < NEW_LINE >  )  {    return new NewLine();  }}/** * Finds whitespaces. */protected Whitespace Whitespace() :{  Token token;}{  (    token = < WHITESPACE >   )  {    return new Whitespace();  }}// =============================================================================// Define the tokens.TOKEN_MGR_DECLS :{  Stack < Integer > stateHistory = new Stack < Integer > ();}// _____________// Skip comments.< DEFAULT, IN_TABBING > SKIP :{  < "%" >  {    stateHistory.push(IN_COMMENT);  }  : IN_COMMENT}< IN_COMMENT > SKIP:{  // Switch back to the previous state on a new line.  <COMMENT_NEW_LINE: <NEW_LINE>>  {    stateHistory.pop();    SwitchTo(stateHistory.isEmpty() ? DEFAULT : stateHistory.peek());  }}< IN_COMMENT > SKIP :{  < ~[ ] >}// ____________________// Tabbing environment./** * There are commands, which have different meanings in tabbing * environments. Handle these commands separately. */< DEFAULT, IN_COMMENT >TOKEN :{  // Switch into IN_TABBING state on "\begin{tabbing}"  < BEGIN_TABBING : < COMMAND_PREFIX > "begin" (< WHITESPACE >)* < GROUP_START > "tabbing" < GROUP_END >>  {    stateHistory.push(IN_TABBING);  }  : IN_TABBING}< IN_TABBING >TOKEN :{  // Switch back to the previous state on "\end{tabbing}"  < END_TABBING : < COMMAND_PREFIX > "end" (< WHITESPACE >)* < GROUP_START > "tabbing" < GROUP_END >>  {    stateHistory.pop();    SwitchTo(stateHistory.isEmpty() ? DEFAULT : stateHistory.peek());  }}// ______________________________// Define a valid text character.< DEFAULT, IN_TABBING >TOKEN :{    <WHITESPACE:    (" " | "\t" | "\f") >  | <NEW_LINE:      ("\r\n" | "\n" | "\r") >  | <NEW_PARAGRAPH: <NEW_LINE> (<WHITESPACE>)* <NEW_LINE> ((<WHITESPACE>)* <NEW_LINE>)*>}< DEFAULT, IN_TABBING >TOKEN :{    <STAR:    "*">}// _____________________________________________// Define the valid group starts and group ends.< DEFAULT, IN_TABBING >TOKEN :{  < GROUP_START : "{" >| < GROUP_END : "}" >}// _______________________________________________// Define the valid option starts and option ends.< DEFAULT, IN_TABBING >TOKEN :{  < OPTION_START : "[" >| < OPTION_END : "]" >}// _________________________________// Define the common command prefix.< DEFAULT, IN_TABBING >TOKEN :{  < COMMAND_PREFIX : "\\" >}< DEFAULT, IN_TABBING >TOKEN :{  < DEF_COMMAND_PREFIX : ("\\def") >}< DEFAULT, IN_TABBING >TOKEN :{  < NEW_COMMAND_PREFIX : ( "\\newcommand" | "\\renewcommand") >}// _____________________________// Define well-defined commands.< DEFAULT >TOKEN :{  < WELL_DEFINED_DEFAULT_COMMAND :    (      "\\-" // optional hyphenation.    | "\\<"    | "\\>"    ) >}< IN_TABBING >TOKEN :{  < WELL_DEFINED_TABBING_COMMAND :    (      "\\=" // in tabbing environment sets a tab stop.    | "\\'" // in tabbing environment moves current column to the right of the previous column.    | "\\`" // in tabbing environment moves all text which follows (up to \\) to the right margin.    | "\\<" // in tabbing environment puts text to left of local left margin    | "\\>" // in tabbing environment is a forward tab. Otherwise, medium space    | "\\+" // in tabbing environment moves the left margin of the next and all the following commands one tab stop to the right.    | "\\-" // in tabbing environment moves left margin to the left by one tab stop.    | "\\kill" // in tabbing environment allows you to set tab stops without producing text    ) >}< DEFAULT, IN_TABBING >TOKEN :{  < WELL_DEFINED_COMMON_COMMAND :    (      "\\ " // ordinary space after period    | "\\" < NEW_LINE > //     | "\\!" // negative thin space    | "\\#" // prints a pound sign: #.    | "\\$" // prints a dollar sign: $.    | "\\%" // prints a percent sign: %.    | "\\&" // prints an ampersand: &.    | "\\(" // start math mode. Same as \begin{math} or $.    | "\\)" // end math mode. Same as \end{math} or $    | "\\*" // is a discretionary multiplication sign, at which a line break is allowed    | "\\+" // moves left margin to the right by one tab stop. Begin tabbed line    | "\\," // thin space    | "\\/" // inserts italics adjustment space    | "\\:" // medium space    | "\\;" // thick space    | "\\@" // declares the period that follows is to be a sentence-ending period    | "\\[" // same as \begin{displaymath} or $$.    | "\\]" // same as \end{displaymath} or $$.    | "\\\\" // terminates a line    | "\\\\*" // terminates a line, but disallows a pagebreak.    | "\\_" // is an underscore, as in hours worked.    | "\\{" // prints a curly left brace: {.    | "\\}" // prints a curly right brace: }.    | "\\|" // is || (math mode).    | "$" // begins or ends math mode.    | "$$" // begins or ends math mode.    | "\\-" // optional hyphenation.    ) >}// _______________________// Define escape commands.< DEFAULT >TOKEN :{  < ESCAPE_COMMAND_DEFAULT_NAME :    (      "\\=" // makes a macron accent    | "\\-" // per default, optional hyphenation.    | "\\'" // per default, makes an acute accent, as ó.    | "\\`" // per default, makes a grave accent, as `o.    ) >}< IN_TABBING >TOKEN :{  < ESCAPE_COMMAND_TABBING_NAME :    (      "\\a´" // makes an acute accent in tabbing environment, as ó    | "\\a`" // makes a grave accent in tabbing environment, as ò    | "\\a=" // makes a macron accent in tabbing environment    ) >}< DEFAULT, IN_TABBING >TOKEN :{  < ESCAPE_COMMAND_COMMON_NAME :    (      "\\\"" // makes an umlaut, as ö.    | "\\^" // makes a circumflex, as â    | "\\~" // makes a tilde over a letter    | "\\." // puts a dot accent over a letter,    ) >}// ______________// Define Marker.< DEFAULT, IN_TABBING >TOKEN :{  < MARKER : "#" < DIGIT >>}// ______________< DEFAULT, IN_TABBING >TOKEN : {    < #UPPERCASE_CHAR : ([ "A"-"Z" ] | "\u00d6" | "\u00c4" | "\u00dc" ) >  | < #LOWERCASE_CHAR : ([ "a"-"z" ] | "\u00f6" | "\u00e4" | "\u00fc" | "\u00df" ) >  | < DIGIT : [ "0"-"9" ] >  | < CHAR : (< UPPERCASE_CHAR > | < LOWERCASE_CHAR >) >}< DEFAULT, IN_TABBING >TOKEN :{  < OTHER_SYMBOL : ~[ ] >}