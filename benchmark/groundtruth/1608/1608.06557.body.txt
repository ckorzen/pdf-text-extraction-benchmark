Neural Networks with Smooth Adaptive Activation Functions for Regression

Introduction

Neural Networks (NNs), especially Convolutional Neural Networks (CNNs), improved the state-of-the-art on multiple classification tasks [\cite=he2015delving] and regression tasks [\cite=belagiannis2015robust] [\cite=szegedy2013deep]. We advocate the use of Adaptive Activation Functions (AAF) in NNs applied to regression problems for two reasons. First, recent studies showed that AAFs improve the classification performance of NNs [\cite=agostinelli2014learning] [\cite=he2015delving] [\cite=jin2015deep]. Second, the output of a regression NN should be accurate for a range of ground truth values, as supposed to only two binary labels. Thus, a NN with a fixed architecture tends to have larger biases in regression tasks, compared to classification tasks. To address this problem, we argue that applying AAFs on the regression (second-to-last) layer can reduce the model bias in regression problems more efficiently than adding more neurons.

In contrast to conventional non-adaptive activation functions, AAFs have parameters that are trained along with other parameters in the NN. It is rather challenging to construct and apply AAFs. If an AAF is too simple, it may not be able to approximate the optimal activation function to a desired degree of approximation error, especially for regression problems. On the other hand, complex AAFs might lead to severe overfitting. Designing the AAF with the right approximation power and complexity for each application is contingent on experience and trial-and-error.

AAFs with a simpler form utilize predefined functions. Conservative methods adjust the parameters like the slope of a sigmoid-like activation function [\cite=Bai2009]. These AAFs are limited in form but often yield a faster convergence rate. Other predefined functions or combinations of functions with adjustable parameters [\cite=conf/ijcnn/XuZ00] [\cite=journals/eaai/IsmailJZZ13] improve the approximation ability of AAFs. Using these AAFs led to better classification accuracy or architectures with fewer model parameters. In these approaches, the AAFs are linear combinations of sub-functions or nested sub-functions including the sigmoid, exponential, sine, eaning:NTF . etc atcode:NTF a etc. etc.. Their major drawback is that the set of sub-functions need to be selected carefully for different datasets, so that the optimal shape of the activation function is approximated to a desired degree of error, without introducing too many parameters.

Piecewise polynomials are well-developed tools for constructing general and complex form AAFs. Specific parameterizations, eaning:NTF . e.g atcode:NTF a e.g. e.g.  Splines, can handle control points implicitly [\cite=Guarnieri_spline] [\cite=conf/ijcnn/HongGC11]. However, the training processes of these methods are very complex. Additionally, too many parameters are introduced for each polynomial segment, increasing the probability of severe overfitting. Non-Spline piecewise linear or quadratic parameterizations [\cite=journals/tnn/Hikawa03a] [\cite=HopfieldLinear] have issues of discontinuity, non-differentiability or unbounded smoothness, due to their parameterizations.

Note that in most of the methods mentioned so far, one global AAF is applied on all neurons. Recent research in deep CNNs proposed to learn an AAF for each layer of neurons or even individual neurons [\cite=goodfellow2013maxout] [\cite=he2015delving] [\cite=agostinelli2014learning] [\cite=jin2015deep], as an alternative for reducing model bias. Extending the non-adaptive Rectified Linear Units (ReLU) to Parameterized Rectified Linear Units (PReLU) [\cite=he2015delving] introduces a parameter which controls the slope of the activation function. Activation functions at different layers have the same form, but different slope. A maxout neuron [\cite=goodfellow2013maxout] outputs the maximum of a set of linear functions. It can approximate any convex function and achieved state-of-the-art performances on multiple classification tasks. Adaptive Piecewise Linear Units (APLU) [\cite=agostinelli2014learning] learn the position of break points and the slope of linear segments simultaneously during training. As each neuron learns its own maxout function or APLU, the number of parameters in the NNs significantly increases with no clear principles of how to avoid severe overfitting.

To conclude, there are two types of existing AAFs: simple AAFs that do not guarantee a bounded approximation ability and complex AAFs that cannot avoid severe overfitting in a principled manner. Viewed in the bias-variance tradeoff paradigm [\cite=bishop2006pattern], existing AAFs do not guarantee bounded bias and complexity (variance). We propose a novel AAF named Smooth Adaptive Activation Function (SAAF) with piecewise polynomial form. Given a fixed degree of bias or complexity, an SAAF can achieve lower complexity or bias, than existing AAFs. In particular, an SAAF can be regularized under any complexity in terms of the Lipschitz constant of the function and can approximate any function simpler than the given complexity ( eaning:NTF . i.e atcode:NTF a i.e. i.e., with a smaller Lipschitz constant) to an arbitrarily small bias. To regularize SAAF's Lipschitz constant, one can simply apply L2 regularization on its parameters. In contrast, there are no methods that regularize the complexity of existing AAFs in a principled manner. Furthermore, most existing AAFs can not guarantee a bounded function approximation error. We show an upper bound of the fat-shattering dimension for an NN by the Lipschitz constant of its AAFs. Therefore, the Lipschitz constant of AAFs is a good measurement of model complexity. Figs. [\ref=fig:firstfig] and [\ref=fig:notoverfitting] show examples and properties of SAAFs. Our contributions are:

We propose a Smooth Adaptive Activation Function (SAAF) with piecewise polynomial form that can achieve low model bias and complexity at the same time:

Low model bias: SAAFs can approximate any one-dimensional function to any desired degree of error, given sufficient number of polynomial segments.

Low model complexity: NNs with SAAFs have bounded model complexity in terms of fat-shattering dimension, given a bounded (L2 regularized) magnitude of the parameters, regardless of the number of polynomial segments.

For any Lipschitz continuous regression model, we prove an exact upper-bound for the fat-shattering dimension without other model assumptions. To our best knowledge, such bound does not exist in the literature.

We propose to use SAAFs on the regression (second-to-last) layer of regression NNs. Our experimental results are better than current state-of-the-art on multiple pose estimation and age estimation datasets.

Regression neural networks

In this section we decompose the learning process of a regression NN to a summation of many one-dimensional function learning processes. Based on this, we argue that applying AAFs on the regression (second-to-last) layer can achieve a small model bias using a small number of parameters. Without loss of generality, assume a regression NN has only one output neuron which outputs a real value y as the prediction, expressed as: [formula], where [formula] are the outputs from neurons in the previous layer, [formula] are the weights of the output neuron's input synapses, and b is a bias term. We train the NN to minimize the expected regression loss on the training set [formula], where [formula] is the set of trainable parameters of the NN. For a multi-layer NN, the output of a neuron oi is computed by applying the i-th activation function [formula] on the input pi, expressed as [formula]. Note that [formula] do not necessarily have the same form. Notably, for almost all of the activation functions, there exists a function [formula] such that [formula] holds for all hi, oi. For example, [formula] for ReLU, Leaky ReLU (LReLU) [\cite=maas2013rectifier] and PReLU. Thus: [formula]. In other words, the final prediction of a regression NN is equivalent to the summation of activation function outputs. We denote [formula] as xi, therefore:

[formula]

In the future, we refer to the neurons/layer connected to the output neuron as "regression neurons/layer". These regression neurons have activation functions [formula].

We consider the regression loss E and the set of hypotheses functions defined by Eq. [\ref=equ:cuted]. We assume on a training set, the loss is minimized such that y  =  t. We also assume [formula] are mutually independent on the training set. Then [formula] for all i, where [formula] is the expectation of ground truth t given xi and Bi is a constant.

From the assumption of y = t, we have [formula] on all training data. Taking the conditional expectation of x1 on both sides, we have [formula]. Based on the assumption that [formula] are mutually independent, [formula] and [formula] for every i  ≥  2. Thus [formula] where [formula].

Theorem [\ref=the:0] shows that [formula] is a one-dimensional function that approximates t given feature xi, ignoring constant B. Therefore, it is very important to be able to learn this one-dimensional function that can achieve small model bias. Although the assumption of mutually independent [formula] in theorem [\ref=the:0] might not always hold, we found in practice that usually [formula] does approximates t in real world datasets, as shown in Fig. [\ref=fig:smthact_pose]. If all of the activation functions [formula] have the same simple form, eaning:NTF . e.g atcode:NTF a e.g. e.g., ReLU, then all of the features xi must be correlated with t linearly. To generate those features xi, more neurons and layers are needed. We propose to model [formula] as AAFs. In this way, we can add a small number of parameters to achieve small model bias efficiently. In our experiments, applying AAF on the regression layer adds less than 1% to the total number of NN parameters and less than 10% to the training time.

Smooth adaptive activation function

We introduce the Smooth Adaptive Activation Function (SAAF) formally in this section and show its advantages in Sec. [\ref=sec:properties]. Given n + 1 real numbers [formula] in ascending order and a non-negative integer c, using [formula] as the indicator function, we define the SAAF as:

[formula]

The SAAF [formula] is piecewise polynomial. Predefined parameters c and ak are the degree of polynomial segments and break points respectively. The parameters wk and vj are learned during the training stage. [formula] and [formula] are basis functions and [formula] is a linear combination of these basis functions. [formula] is the boxcar function. [formula] is the integral of [formula], which looks like the step function. [formula] is the integral of [formula], which looks like the ramp function or ReLU. The degree of the polynomial segments in [formula] is determined by the degree of the basis functions [formula] and [formula]. Fig. [\ref=fig:firstfig] visualizes the construction of [formula].

Based on this parameterization, we can see that the order of polynomial segments can be defined to an arbitrary number. This allows the SAAF to have a larger variety of forms compared to existing AAFs. Additionally, for each polynomial segment, there is only one parameter controlling the c-th order derivative within the segment. Derivatives of lower order are guaranteed to be continuous across the entire SAAF, including the locations of break points. By regularizing the parameters [formula], the magnitude of the c-th order derivative is regularized. In other words, the resulting activation function is smooth. As a result, NNs with SAAFs are smooth functions. Fig. [\ref=fig:notoverfitting] gives examples of one-dimensional function learning.

SAAF properties

We discuss properties and advantages of SAAFs in detail. In summary, an SAAF can approximate any one-dimensional function to any desired degree of accuracy given a sufficient number of segments. NNs with SAAFs have bounded fat-shattering dimension when the NN parameters are regularized.

SAAFs as universal approximators

Piecewise polynomials can approximate any one-dimensional continuous function to any degree of error given sufficiently small polynomial segments [\cite=larson2013finite]. Because the range of a neuron's input is bounded in practice, an SAAF with a sufficient number of polynomial segments can approximate any function to any degree of error. Moreover, an SAAF with a finite Lipschitz constant can approximate any function that has a smaller Lipschitz constant.

An NN with SAAFs is Lipschitz continuous

We show that because the smoothness of an SAAF can be regularized, a feedforward NN with SAAFs is Lipschitz continuous, given a bounded magnitude of the parameters in the NN. A function [formula] is Lipschitz continuous if there exists a real constant L such that for any α1 and α2 in the domain of [formula], [formula]. We use the Euclidean norm in this paper. The constant L is the Lipschitz constant of [formula].

Assuming a bounded range of input x, obviously the maximum derivative magnitude of [formula] is its Lipschitz constant. Therefore, L can be derived by integrating the parameters [formula] and [formula].

[formula]

where [formula]. For example, given c = 1, [formula]. Given c = 2, [formula]. It has been shown [\cite=anthony2009neural] that if the activation functions in an NN are Lipschitz continuous, then the NN is Lipschitz continuous.

Note that NNs with other activation functions such as the Sigmoid, ReLU and PReLU are also Lipschitz continuous given a bounded magnitude of their parameters. Therefore, NNs with combinations of such activation functions and SAAFs are also Lipschitz continuous. However, NNs with these activation functions tend to have large model bias, as argued in Sec [\ref=sec:desired].

Bounded model complexity

In this section, we prove an upper bound of the model complexity in terms of fat-shattering dimension [\cite=bartlett1994fat] for any Lipschitz continous model (function) such as NNs with SAAFs. Given two models with the same training error, the model with a lower fat-shattering dimension has a better expected generalization error [\cite=anthony2009neural]. Upper bounds of the fat-shattering dimension have been proven [\cite=journals/tit/Bartlett98] [\cite=anthony2009neural] for Lipschitz continuous NNs under assumptions such as the magnitude of NN parameters. We prove an exact upper bound for any Lipschitz continuous regression model with no other model assumptions.

The fat-shattering dimension is a scalar-related dimension defined as follows: Suppose that F is a set of functions mapping from a domain X to [formula], [formula] is a subset of the domain X, and γ is a positive real number. Then D is γ-shattered by F if there exist real numbers [formula], such that for all [formula], there exists a function [formula] in F, such that for all 1  ≤  i  ≤  m,

[formula]

The fat-shattering dimension of F at scale γ, denoted as [formula], is the size of the largest subset D that is γ-shattered by F.

Suppose all data points lay in a d-dimensional cube of unit volume. All functions in function set F have a Lipschitz constant L. Then, the set F has bounded fat-shattering dimension:

[formula]

For simplicity, we consider shattering two points [formula] and [formula] with t1 and t2 only. Without loss of generality, assume t1  ≥  t2. If [formula] satisfies Eq. [\ref=equ:fat] when b1  =  1, b2 = 0, then we have [formula]. Denote [formula]. According to the definition of Lipschitz continuity, we have 2γ  ≤  sL. In other words the distance s between two points must be no smaller than 2γ / L in order for F to possibly γ-shatter them. Next we derive [formula] which is the maximum number of points F can γ-shatter in a cube of unit volume. Those points form a simplex mesh of at least [formula] number of simplexes. The nodes of the simplex mesh are the data points [formula] that we expect F to possibly γ-shatter. The side length of each simplex should be at least 2γ / L. Therefore the total volume of the mesh is no smaller than [formula], where [formula] is the volume of a d-dimensional regular simplex of unit side length. Because we assume the volume of the simplex mesh (where all data points lay) is no greater than 1, we have [formula]. If we expand Vd, we derive Eq. [\ref=equ:fatbyme].

From theorem [\ref=the:1], when L decreases, the fat-shattering dimension decreases polynomially. For an NN with SAAFs, since L is bounded by the magnitude of the NN parameters, regularizing the parameters will reduce model complexity polynomially.

Experiments

We tested NNs with piecewise linear (c=1) and quadratic (c=2) SAAFs on six real world datasets. We implemented NNs using Theano [\cite=Bastien-Theano-2012]. In all experiments, we added 10- 5 times the L2 norm of all NN parameters as a regularization term in the loss function. We also use batch normalization [\cite=ioffe2015batch] to speed up the training process. The activation functions we tested are:

Rectified Linear Units (ReLU) [\cite=maas2013rectifier]. Rectifier networks have been successful in many applications.

Leaky Rectified Linear Units (LReLU) [\cite=maas2013rectifier]. LReLU has a fixed negative slope α when the input is negative. We set α =  - 1 / 3 in all experiments.

Parametric Rectified Linear Units (PReLU) [\cite=he2015delving]. Compared to LReLU, PReLU is an AAF with a learnable slope. In CNNs, neurons that share the same filter weights also share the same slope.

Adaptive Piecewise Linear Units (APLU) [\cite=agostinelli2014learning]. APLU is a piecewise linear parameterization that is different from SAAF. In all experiments, we use 5 linear segments as suggested by [\cite=agostinelli2014learning].

Piecewise linear and quadratic SAAF (SAAFc1 and SAAFc2), our proposed method. In CNNs, neurons that share the same filter weights also share the same SAAF parameters. We randomly chose 22 as the number of segments, based on our proof that the model complexity can be bounded regardless of the number of polynomial segments. Break points are distributed from - 1.1 to 1.1.

According to Sec [\ref=sec:desired], AAFs on the regression neurons are especially important. Therefore we also tested the variant of applying AAFs only to regression neurons, instead of all neurons. In this case, neurons other than the regression neurons used ReLU. We distinguish AAFs only on regression neurons with prefix R- such as R-APLU, R-SAAFc1 eaning:NTF . etc atcode:NTF a etc. etc.. Note that R-ReLU is equivalent to ReLU.

On six datasets, NNs with proposed SAAFs reduced the error of NNs with ReLU, LReLU, PReLU, APLU by 4.2-22.6%, 6.6-20.8%, 4.7-21.1%, 7.4-25.0% respectively. Notably, on several pose estimation and age estimation datasets, we followed the training and testing set split scheme in the literature and achieved state-of-the-art results.

Pose estimation

Pose estimation is a fundamental problem in computer vision [\cite=chen2014articulated]. We focus on estimating human pose in single frame human images. Following a recent approach [\cite=belagiannis2015robust], we address this problem by regressing a set of joint positions. There are 14 joint locations: bottom/top of head, left/right ankle, knee, hip, wrist, elbow, and shoulder. Each joint position is expressed by the x and y coordinates. Thus, in total there are 28 real numbers associated with each human image. Also following [\cite=belagiannis2015robust], we used the widely used observer-centric ground truth [\cite=chen2014articulated]. We tested our method on the LSP [\cite=johnson2010clustered] and volleyball [\cite=belagiannis2014holistic] datasets containing 2000 and 1107 cropped human images respectively. We did not use the other two datasets in [\cite=chen2014articulated] because they contain only 100 to 200 training images. We used the same evaluation metric: Percentage of Correctly estimated Parts (PCP) as in [\cite=belagiannis2015robust].

We implemented the current state-of-the-art regression NN [\cite=belagiannis2015robust] as the baseline. We used the same network architecture, Tukey's biweight loss function, and cascade of four CNNs, and just changed the CNN's activation function. Additionally, we doubled the amount of NN filters and applied extensive data augmentation on the training set. In all datasets, NNs with proposed SAAFs achieved better results than NNs with other activation functions, shown in Tab. [\ref=tab:poseoverall]. In order to examine the effect of adding additional layers with non-adaptive activation functions compared to using SAAFs, we experimented with a ReLU NN with one additional 1K node layer. Performance increased from 62.6% to 63.7% whereas using R-SAAFc2 on the original smaller NN achieved 68.6%. Using the cascade of four CNNs [\cite=belagiannis2015robust], our proposed method (R-SAAFc2 cascade) outperformed the current state-of-the-art regression NN [\cite=belagiannis2015robust], as shown in Tab. [\ref=tab:poseresults]. Examples of pose estimation results with our method are given in Fig. [\ref=fig:pose].

Age estimation

We applied our method on two age estimation datasets: the Adience [\cite=eidinger2014age] and the ICCV 2015 ChaLearn-AgeGuess challenge dataset [\cite=escalera2015chalearn]. The goal is to predict the age of people from facial images. The Adience dataset contains 26K facial images in 8 age groups, along with a cross-validation data separation scheme. We predicted the age groups as a regression problem. The Chalearn-AgeGuess (AgeGuess) dataset contains 2.4K training and 1K validation facial images. The challenge has not released the testing set, Thus we compared the validation error with other methods.

The architecture of the network was similar to the VGG 16-layer net [\cite=Simonyan14c]. We used less filters and layers. We used 1  ×  1 convolutional filters as a Network In Network (NIN) model [\cite=lin2013network]. We cropped the faces out from images using a face detection method [\cite=mathias2014face]. Then facial images were resized to 120 ×   90 followed by the extensive data augmentation method useded in Sec. [\ref=sec:pose]. For experiments on the AgeGuess dataset, we first pretrained our CNNs on the Adience dataset. The results are shown in Tab. [\ref=tab:ageestimation]. We achieved state-of-the-art result on the Adience dataset. We achieved the best single CNN results on the AgeGuess dataset. Better results in the challenge [\cite=escalera2015chalearn] used extensive prediction fusions (at least 4 CNNs) and very large external datasets (at least 100X larger than the AgeGuess dataset).

Facial attractiveness prediction

We focus on learning personal preferences of facial attractiveness on web-quality facial images. We constructed a dataset by applying the Viola-Jones' face detection algorithm [\cite=viola_jones_2001a] on female images downloaded from hotornot.com. The dataset contains 2K RGB facial images of 120×  90 pixels. Three individuals independently rated the images with facial attractiveness scores ranging from 0 to 20. We randomly selected one of the three raters to provide the training and testing labels. Labels from the other two raters were only used to compute inter-observer agreement. We used the same CNN architecture in Sec. [\ref=sec:age]. Results are shown in Tab. [\ref=tab:facialResults]. The CNN with our SAAFc2 achieved the best three fold random-split-validation results. Our results are close to inter-observer agreement.

Learning the circularity of nuclei in pathology images

Hematoxylin and eosin stained pathology images provide rich information to diagnose, classify and study cancer. One diagnostic criterion is the shape of nuclei [\cite=braak2003staging]. We use CNNs to learn the circularity of nuclei in pathology images of glioma which is the most common brain cancer. Existing methods analyze the shape of nuclei from automatically segmented nuclei [\cite=al2010improved]. We used the training set from the MICCAI 2015 nucleus segmentation challenge [\cite=miccainucleussegmentation] which contains 1K images of nuclei. We derived the ground truth circularity measurements from the ground truth nuclear segmentation masks and used CNNs to learn the circularity from nuclear images. Experiments show that our CNN-predicted circularity is more accurate than the circularity directly computed from automatically segmented nuclei. In the results, shown in Tab. [\ref=tab:nuclearResults], the CNN with our R-SAAFc1 achieved the best three fold random-split-validation result. Note that, data-driven regression achieved better results, compared to computing circularity of nuclei directly from automatic nuclei segmentation results.

Conclusions

We have demonstrated theoretically and experimentally that using Adaptive Activation Functions (AAF) on the regression (second-to-last) layer can improve the performance of a regression NN. We proposed a novel AAF named Smooth Adaptive Activation Function (SAAF) which has multiple advantages. First, an SAAF can approximate any function to a desired degree of error. Second, using parameter regularization, an NN with SAAFs represents a Lipschitz continuous function which leads to bounded model complexity in terms of the fat-shattering dimension. Based on these two advantages, an NN with SAAFs can achieve lower model bias and complexity than NNs with other AAFs. We tested different setup of SAAFs in various NN architectures on several real world datasets. The improvements are consistent across all tested datasets compared to adaptive and non-adaptive activation functions. We achieved state-of-the-art results on multiple datasets. In the future, we will test SAAFs in classification NNs.