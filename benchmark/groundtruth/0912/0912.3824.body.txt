=1

D..

>m

Highly accelerated simulations of glassy dynamics using GPUs: caveats on limited floating-point precision

Introduction

In recent years, the computational power of graphics processing units (GPUs) has increased rapidly: the theoretical peak performance for single precision floating-point operations on an amateur's GPU reaches nearly . Compared to a single core of a conventional processor, this gives rise to an expected performance jump of one or two orders of magnitude for many demanding computational problems, fueling the desire to exploit graphics processors for scientific applications. While conventional high-performance computing (HPC) depends on expensive central computing clusters, shared amongst many researchers, GPU computing makes local clusters acting as small HPC facilities conceivable for large-scale simulations at a fraction of the cost.

A modern GPU works as a streaming processor implementing the single--- (SIMT) model. One device contains several hundred scalar processor cores executing a single instruction or a small set of divergent instructions in parallel in thousands of threads on a large data set. Parallel, coalesced access to the onboard device memory via a memory interface of up to 512 bits provides a remarkably high memory bandwidth.

Molecular dynamics (MD) simulations--a widespread tool for particle-based simulations in biological physics, chemistry, and material science--are ideally applicable to the GPU due to their inherent parallelism. The release of NVIDIA's compute unified device architecture (CUDA) as a convenient means of GPU programming has triggered a lot of activity in exploiting GPUs for scientific applications. Several MD implementations using GPUs have demonstrated significant speedups, with performance measurements based on relatively short test runs [\cite=Anderson2008] [\cite=Meel2008] [\cite=Liu2008] [\cite=Stone2007] [\cite=Yang2007]. A critical review of current attempts to exploit GPUs in MD simulations may be found in Ref. ; in essence, published results are not yet available, showing the "nascent nature" of the field. As a notable exception, complex MD simulations targeting at protein folding were accelerated by GPUs allowing for the trajectories to reach into the millisecond regime [\cite=Voelz:2010] [\cite=Harvey:2009]. In the realm of physics, we are only aware of a Monte-Carlo study of the critical behaviour of the Ising model that was performed on the GPU, reporting speedups between 35 and 60 for the mostly integer arithmetic-based algorithm [\cite=Preis2009]; a multi-GPU approach to this problem shows a promising scalability [\cite=Block2010].

In this article, we describe MD simulations that are fully implemented on the GPU and that faithfully reproduce the glassy dynamics of a supercooled binary mixture. If a glass-forming liquid is cooled or compressed, the structural relaxation critically slows down by several orders of magnitude and a rapidly growing time scale emerges close to the glass transition line [\cite=Goetze:MCT]. Small changes in the temperature may already have drastic effects on the dynamics, and a numerical study thus requires excellent long-time stability with respect to energy conservation over long simulation runs of MD integration steps and more. The single precision floating-point arithmetic provided by recent GPUs turns out to be a major obstacle to this goal. But once this limitation is overcome, general-purpose computing on GPUs provides a useful tool to address current questions of the glass transition with minimal allocation of hardware and reasonable computing time.

The substantial enhancement of computing resources due to GPU computing facilitates the investigation of very large systems, which is desirable for studies of phenomena associated with a divergent length scale. Only recently, evidence for a divergent static correlation length in supercooled liquids was found in large-scale simulations of up to 64,000 particles [\cite=Mosayebi2010] and 80,000 particles [\cite=Flenner2010], respectively.

The article is organised as follows. We describe a high-precision implementation for the GPU in Section [\ref=sec:implementation], followed by performance benchmarks in Section [\ref=sec:performance]. A detailed analysis of the long-time stability regarding momentum and energy conservation is given in Section [\ref=sec:stability]. Section [\ref=sec:glassy] demonstrates the impact of numerical accuracy on the simulation results for the glassy dynamics of a binary mixture of soft spheres. A conclusion is given in Section [\ref=sec:conclusion].

Implementation for the GPU

Architecture of the GPU hardware

An MD implementation for the GPU needs to be adapted to its vastly different architecture. A modern GPU consists of hundreds of scalar cores, which map to execution threads in the CUDA architecture and require fine-grained parallelisation of the algorithm. The scalar cores are divided into multiprocessors--units of 8 processors for the NVIDIA G200 series GPUs--capable of executing an atomic warp of 32 threads in four clock cycles. Each multiprocessor is equipped with a total of 16,384 32-bit registers, and a fast, tiny shared memory of 16 kB; all multiprocessors access a large global device memory of 1 to 4 GB, which is two orders of magnitude slower than local registers. To hide latencies when accessing the global device memory, a scheduler concurrently executes multiple warps on a multiprocessor. The equivalent of a multiprocessor in the CUDA architecture is a block of up to 512 threads, and the only means of communication and synchronisation is within a block. For the execution of complex algorithms, the number of threads per block has to be lowered due to the limited number of registers available per multiprocessor. Global device memory enforces a strict memory access pattern, where threads have to address memory in a linear coalesced order. In contrast to shared memory access, random read and write access to global device memory entails a performance penalty of an order of magnitude. This impairs GPU acceleration of many common computational primitives such as sorting algorithms. As a partial remedy a texture cache of up to 8 kB per multiprocessor, which stems from the graphics heritage of the GPU, enables read-only random access to a small window of global device memory. A global cache of 64 kB of constant memory provides access to constant data at speeds comparable to register access.

The MD integration step

A soft-sphere molecular dynamics (MD) simulation solves Newton's equations in discretised time for N classical particles interacting via a C2-continuous, short-ranged potential. Every MD step, the force on each particle exerted by all interacting particles is calculated, and the particles are propagated by a symplectic integrator, the velocity-Verlet algorithm [\cite=Rapaport2004]. A naïve implementation based on a doubly nested force loop would yield an algorithmic complexity of O(N2). For short-ranged interparticle forces however, a linear scaling of the performance with the number of particles can be achieved with Verlet neighbour lists. For each particle, a list of particles located within a radius rc, the cutoff radius of the potential, is kept in memory; the force algorithm then considers only particles in the neighbour list. A small "skin" of a fraction of rc is added to the neighbour sphere to reduce the necessity of rebuilding the neighbour lists to every 10 to 100 steps. Particle binning--the decomposition of the system into spatial cells--avoids a doubly nested loop in the neighbour list algorithm by limiting the search for neighbours of a particle to its own and the adjacent cells. Our implementation for the GPU combines and extends concepts described in detail in Refs. [\citealp=Anderson2008] and [\citealp=Meel2008].

Parallelisation of the velocity-Verlet algorithm for the GPU is straightforward and naturally respects coalesced memory access: each CUDA thread is assigned a single particle with the task of updating the velocities and coordinates. The implemented force and neighbour list algorithms resemble the ones proposed in Ref. [\citealp=Anderson2008]. Specifically in the force algorithm, each thread reads the indices of a particle's neighbours in a coalesced manner, and coordinates are then fetched using the texture cache, mitigating performance penalties due to random memory access.

For particle binning, we have implemented a cell list algorithm based on a parallel radix sort [\cite=Knuth1998] [\cite=Zagha1991]. Each particle is assigned a one-dimensional integer cell index. An array containing the particle numbers is sorted according to the cell indices, as proposed in the Particles example of the CUDA SDK [\cite=CUDA_SDK]. A further pass determines the start index of each cell, followed by the assembly of fixed-size cell lists for the subsequent neighbour list algorithm. With this method we avoid the bottleneck of a host to device memory copy which is needed with the CPU-based cell list algorithm of Ref. [\citealp=Anderson2008]. The radix sort algorithm performs worse on the GPU than on the CPU for small systems of considerably less than particles, and further, particle binning is only necessary every 10 to 100 steps. Thus, the overall performance of the MD step is best for systems of and more particles.

The neighbour list algorithm finally reads the particle indices from the fixed-size cell lists to gather coordinates and velocities of particles in neighbouring cells via texture fetches, temporarily stores them in shared memory, and builds a fixed-size neighbour list [\cite=Anderson2008].

A parallel reduction scheme on the GPU is used to calculate properties which are needed every MD step such as the maximum absolute particle displacement and the potential energy sum as well as less frequently evaluated properties such as temperature, centre-of-mass velocity, and the virial tensor.

In the force algorithm, we make efficient use of the texture cache by periodically sorting the particles in global device memory according to a three-dimensional space-filling Hilbert curve [\cite=Sagan1993] [\cite=Anderson2008]. Such a curve provides a mapping between 3D space and 1D memory to optimally conserve spatial locality. In our implementation, the mapping is recursively generated on the GPU using 8 vertex rules [\cite=Wang2005] as depicted in Fig. [\ref=fig:hilbert], based on a lattice spacing of σ with a maximum recursion depth of 10. The subsequent particle sort employs the radix sort algorithm [\cite=Knuth1998] [\cite=Zagha1991] to generate a permutation array; then read access to the texture cache and coalesced write access to global memory are used to efficiently permute particle coordinates and velocities.

Random number generator

A modified Andersen thermostat for pre-equilibration cooling is realised by assigning Boltzmann-distributed velocities to all particles every (μ  δt)- 1 steps according to a fixed heat bath collision rate μ. Furthermore, the assigned velocities are rescaled by means of parallel reduction to exactly match the temperature of the heat bath. We have implemented the parallel rand48 random number generator, which may be trivially parallelised by leap-frogging within the sequence [\cite=Meel2008]. The linear recurrence xt + T  =  ATxt  +  CT mod 248 uses a leapfrog multiplier AT  =  aT mod 248 and leapfrog addend [formula] to jump within the sequence depending on the total number of threads T. As an improvement compared to Ref. [\citealp=Meel2008], we seed the parallel generator using the parallel prefix sum algorithm, which yields the initial state xt for each thread t by binary-tree summation and multiplication. Thus, initialisation times of many seconds are avoided for large systems.

Double-single precision floating-point arithmetic

It will be demonstrated below that numerical long-time stability requires double precision arithmetic in critical parts of the MD step. Currently prevalent GPUs of the NVIDIA GT200 series feature only 1 double precision floating-point unit per every 8 single precision units, which prohibits the use of native double precision in performance-critical algorithms.

The limited native precision is overcome by algorithms which implement multi-precision arithmetic using two native floating-point registers [\cite=Dekker1971] [\cite=Knuth1997]. On hardware supporting the IEEE 754-1985 floating-point standard [\cite=IEEE754-1985], proofs of numerical exactness have been given for multi-precision addition and multiplication [\cite=Lauter2005]. For the GPU, which does not fully comply with IEEE 754- in terms of rounding and division, these proofs have been adapted for double-single precision arithmetic using two native single precision floats [\cite=Gracca2006]. The double-single precision algorithms for addition and multiplication with NVIDIA GPUs yield an effective precision of 44 bits.

For IEEE 754- compatible hardware, the DSFUN90 package for Fortran [\cite=Bailey2005] contains implementations of addition, subtraction, multiplication, division, and square root in double-single precision. We have ported these implementations from Fortran to CUDA, extending the functionality provided by the Mandelbrot example of the CUDA SDK [\cite=CUDA_SDK]. As an example the addition algorithm in double-single precision is displayed in Table [\ref=alg:dsfun90_addition]. To implement double-single multiplication on the GPU, care has to be taken to avoid fused multiply-add operations, as the GPU does not round the result of the comprised multiplication, in violation of the floating-point standard. As a remedy, CUDA provides the intrinsic operations __fmul_rn and __fadd_rn.

In double-single precision, we have implemented the update of velocities and coordinates in the velocity-Verlet step as well as the summing over force contributions from neighbouring particles. These may be subject to accumulated summing errors depending on the particular time step and potential, respectively. The evaluation of the force contributions itself, which accounts for a large fraction of the computational cost within the MD step, remains in single precision.

Evaluation of time-correlation functions

The dynamic properties of a molecular system are often quantified in terms of time-correlation functions [\cite=Hansen:SimpleLiquids]. For observables A and B, one defines their correlation at different times t and s as

[formula]

In equilibrium, time-correlation functions are stationary and depend only on the difference t - s, thus CAB(t,s) = CAB(t - s). The most important class of time-correlation functions is comprised by the auto-correlation functions CAA(t). If the system is ergodic, the average may be evaluated alternatively as an ensemble average over initial conditions, i.e., over independent simulation runs. For tagged-particle observables, the statistical error is decreased additionally by averaging over all particles of the same species.

We have developed a blocking scheme which allows the online evaluation of time-correlation functions during the production run. The scheme was inspired by the "order-n algorithm" of Ref. [\citealp=Frenkel:MD]. Complex relaxation processes often comprise several time scales and are usually discussed on a logarithmic time axis. The blocking scheme yields the correlation functions for fast and slow processes simultaneously and provides a time grid already suitable for a logarithmic representation. Introducing some short-time resolution Δt, we assume that the state of the system is stored at times mΔt for [formula], from which the observables Am = A(mΔt) are calculated. For a long simulation run over a time span of T = MΔt, we approximate the integral in Eq. [\eqref=eq:TCF] by a sum,

[formula]

where M' = M - m. The evaluation of C(m)AA for all m would require handling a huge number of M copies of the system state at different times (or of the derived observables at least) and would involve O(M2) floating-point operations. Instead, we arrange the time grid in k blocks of size [formula], where the time resolution between subsequent blocks is increased by a factor of [formula], see Fig. [\ref=fig:blocking_scheme]. Within block n, correlations are calculated for time lags [formula] only, where [formula]. The blocks are continuously filled during the simulation. Whenever a block is full, the first entry is correlated with all other entries and is then discarded. Thus, each block contains a section of the trajectory, moving forward as the simulation progresses. The memory requirement to handle a trajectory of length [formula] is merely [formula] snapshots of the system state.

Performance measurements

A central argument for the use of GPUs in high-performance computing is their high theoretical peak performance compared to that of a single core of a conventional Opteron or Xeon CPU. We did extensive performance measurements of our MD implementation, which we compare first to our own serial reference implementation for the host processor. The comparison between a massively parallel implementation and a serial one is somewhat unfair, in particular in view of the multi-core nature of current CPUs. Thus, we secondly provide a comparison with the LAMMPS package [\cite=Plimpton1995], being one of the established, parallelised MD packages widely used in the physics community. The test includes the parallel use of multi-core CPUs within a single compute node as well as distributed computing over several nodes, which is more realistic for production use and allows for a more reasonable comparison between a conventional cluster and a single GPU; a similar approach was taken recently by Harvey et al. [\cite=Harvey:2009]. LAMMPS offers some GPU acceleration as well which we have not used by purpose and which we explicitly do not refer to.

Our measurements were done on Lennard-Jones liquids of varying size and density with the conventional 12-6 interaction potential, [formula], cut off at rc = 2.5σ; in LAMMPS we used the potential implementation termed lj/cut. Units of length, mass, time, and energy are σ, m, [formula], and ε as usual, and dimensionless quantities are indicated by an asterisk. We used a step size of δt*  =  0.001 and a neighbour list skin of width 0.5σ for the GPU and 0.3σ for the serial CPU and parallel LAMMPS benchmarks. To generate a homogeneous system, an initial fcc lattice was equilibrated in the NVT ensemble at [formula] for steps. Then, the wall time spent on the MD step was measured for the next steps. For the GPU and parallel CPU benchmarks, the results were averaged over 10 independent realisations. For the LAMMPS benchmarks, only a single system was generated and the results were averaged over two consecutive measurement runs of steps each. The investigated system sizes ranged from N = 1,372 to 864,000 particles and the densities from ϱ* = 0.2 to 1.2.

The GPU benchmarks were run on GPUs of type NVIDIA GeForce GTX 280, which contains 240 scalar processor cores clocked at , with GDDR3 memory at providing a device memory bandwidth of 140 GB/s ([formula]). Its theoretical peak single precision floating-point performance based on one fused multiply-add operation and one concurrent multiply operation per cycle is ([formula]). For comparison with our host reference implementation, we used an AMD Opteron 2216 HE processor at with PC2-4200 CL4 dual-channel memory and a theoretical memory bandwidth of 17 GB/s ([formula]). The theoretical peak performance on the assumption of a single SSE instruction execution with four concurrent single precision floating-point operations per cycle is per CPU core. This roughly yields a factor of 100 for the theoretical limit on the speedup of a compute-bound algorithm, and a factor of 8 for an algorithm limited by memory bandwidth. The estimate does not take into account the memory latency on the GPU, which is 400 - 600 clock cycles for a thread accessing global memory [\cite=CUDA_Guide], and may more substantially constrain the overall performance of an algorithm than floating-point performance or memory bandwidth. Further, recent CPUs contain several cores, and typical nodes in a computing centre are found to be 4- to 16-way SMP machines, and one has to put these numbers into perspective for a parallelised implementation making use of all available cores simultaneously.

The GPU benchmarks were performed with HAL's MD package [\cite=Colberg2009] using single floating-point precision on the GPU for comparison with other work, i.e., without the implementation of double-single precision described above. The GPU-specific CUDA code was compiled with NVIDIA's CUDA compiler (version 2.2) targeting compute capability 1.0. The host-specific code was compiled for the x86_64 architecture with the GNU C/C++ compiler (version 4.3.4) with optimisation flag O3. The serial CPU benchmarks were done with HAL's MD package [\cite=Colberg2009]; it was compiled with single floating-point precision for x86_64 using the GNU compiler again with optimisation flag O3, which implies automatic vectorisation of loops. On the x86_64 architecture, GCC defaults to SSE floating-point arithmetic, which ensures that throughout a calculation, a floating-point value is stored with the precision mandated by its data type.

The compute times per MD step obtained on the GPU and the host are compared in Figs. [\ref=fig:performance]a and b, respectively. They are proportional to the number of particles N, and the double-logarithmic representation nicely corroborates the linear complexity of the simulation algorithm. In the GPU case, the linear scaling is only obeyed for sufficiently large [formula]; for smaller N, the compute times show a constant offset of 0.2 - 0.5 ms, reflecting the overhead of parallel sorting and reduction. The prefactor increases for denser systems, which we attribute to larger neighbour lists. At ρ* = 0.4, we measure a GPU time per MD step per particle of ; this value doubles to for the highest density, ρ* = 1.2. For comparison, the timings reported in Refs. [\citealp=Anderson2008] and [\citealp=Meel2008] at ρ* = 0.4 are and per MD step and particle using the older NVIDIA GeForce 8800 GTX hardware with only 128 CUDA cores at .

For the described double-single precision implementation, the execution times on the GPU increase modestly by about 20%. The dependence on system size and density is similar to the results for the single precision implementation in Fig. [\ref=fig:performance]a. Thus, the performance penalty for using single-double precision in critical parts of the algorithm results roughly in a global factor. A significant part of the additional execution time seems to be related to memory latency. Using double-single precision, twice the amount of data is read and written for velocity and position vectors. For the three-dimensional velocity vectors, this totals to 3  ×  2 = 6 32-bit words per particle, requiring at least two coalesced memory operations by using, e.g., two arrays of float4. In contrast, the velocity vector can be accessed with a single coalesced operation for single precision. We expect that these considerations hold also if native double precision on the GPU is used, dropping the additional floating-point operations for the double-single arithmetic. CUDA devices of compute capability 2.0 only support texture read operations of up to 128 bytes, which would entail splitting position and velocity vectors into properly aligned double2 and double components, and thus require twice the amount of memory accesses per vector.

On the host processor, the MD step time of the serially executed programme is proportional to N for small system sizes too (Fig. [\ref=fig:performance]b). With increasing system size, the execution times increase slightly, probably due to a growing number of cache misses. In particular, performance degraded substantially (by a factor of 2) for systems of more than particles if the particles were randomly distributed in memory. Thereby, the obtained speedups were spoiled considerably, which we have solved by regularly sorting the particles in memory as in the GPU implementation. The prefactor spreads by about 60% around its average, which is somewhat larger than on the GPU (40%). At ρ* = 0.4, we have measured an MD step time per particle of 1.8 s, which is comparable to the timings obtained below with the LAMMPS package on a single processor core.

The relative performance gain of the GPU over the CPU is displayed in Fig. [\ref=fig:performance]c. It depends to some extend on the particle density such that dense systems are favoured by the GPU. While the speedup factor is as small as 4 to 12 for small systems of just particles, it goes up to values around 40 for particles, and it reaches an approximate plateau between 70 and 80 for more than particles, being close to the theoretical limit for a compute-bound algorithm. The LAMMPS benchmarks were performed at the Leibnizrechenzentrum in Munich on 8-way nodes containing 4 dual-core processors of type AMD Opteron 8218 HE . The tested version of the package was released on 9 January 2009, it was compiled with Intel's C++ compiler (version 10.1) using the optimisation flags O2, ipo, unroll, and fstrict-aliasing. The programme was run in parallel mode using the MPI interface, the nodes were connected via 10 Gigabit Ethernet, and the MPI library used was from Parastation. We have tested configurations with 8, 16, 24, 32, 48, and 64 processes. For each particle number and density, the fastest configuration was selected, and these smallest MD step times are shown in Fig. [\ref=fig:performance]d; only configurations with 1, 2, 6, and 8 nodes are relevant for particle numbers between and . For system sizes [formula], a single node (8 processes) is favourable. Although the parallelisation overhead is significantly smaller than for the GPU, the measured times per MD step exceed those on the GPU for more than 4,000 particles. Restricting the configuration to a single 8-way node even for larger systems, the execution times for particles are found to be 5 to 10 times slower than for the GPU, depending on density; for higher particle numbers, the single-node performance goes drastically down, probably due to frequent cache misses. For a large system of [formula] particles, the fastest execution is obtained with 48 processes, but the time per MD step and particle is about 2 times slower compared to the GPU, in particular at high densities. For huge systems, [formula], the absolute numbers and the spread of the execution times are comparable for the GPU and 64 processes. In conclusion, a single GPU outperforms a conventional cluster by a factor of 2 for large systems and performs similarly as 8 recent 8-way nodes for huge system sizes.

Numerical long-time stability

We have thoroughly tested the numerical long-time stability of our implementation with respect to momentum and energy conservation. In Section [\ref=sec:glassy], we will show how a drift in these quantities may affect the dynamics of the simulated system. Numerical errors will be larger if only single precision arithmetic is used, but the pace at which numerical errors accumulate also depends on the form of the potential. We will compare the Lennard-Jones potential and its purely repulsive part, also known as Weeks-Chandler-Andersen (WCA) potential [\cite=Weeks1971], [formula] which is cutoff at rc = 21 / 6σ. This potential allows for smaller neighbour lists with less particles, speeding up the simulation by up to 40%. Further, we will discuss smoothed versions of the potentials, which possess a continuous second derivative by multiplying with the function [formula]. The following scrutiny is based on a system of N = 10,000 particles at ρ* = 0.75 and T* = 1.12. For either the LJ or the WCA potential, all results share the same initial configuration, which was obtained by equilibrating an initial fcc lattice in the NVT ensemble with μ* = 1, δt* = 0.001 and h = 0.005 over steps using the GPU (double-single precision) implementation.

Momentum conservation

Momentum conservation implies that the interaction between particles does not generate additional momentum or, equivalently, a drift of the centre-of-mass (c.m.) velocity or mean particle velocity, [formula]. For the summation of forces, a standard index loop over the neighbouring cells yields first a large force contribution to one direction, which is later cancelled by the forces from particles on the opposite side. Such an implementation in single precision results in a clear drift of the c.m. velocity for the WCA potential as illustrated in Fig. [\ref=fig:momentum_conservation]a; the drift is an order of magnitude smaller in the case of the LJ potential, Fig. [\ref=fig:momentum_conservation]d. Using double-single precision for the summation of forces and summing opposite cells together reduces the drift by factors of 20 and 2.7 for the WCA and LJ potentials, respectively (panels b and e). The drift of the c.m. velocity is suppressed by another factor of 100(!) in both cases if the velocity-Verlet integration is done in double-single precision too (panels c and f). Modifying the time step of the integration or smoothing the potential does not have a significant effect on the velocity drift.

Energy conservation

Faithful simulations in the microcanonical ensemble crucially depend on the conservation of the total system energy, [formula]. This condition is particularly sensitive to limited floating-point precision and requires particularly careful examination. For example, an energy drift of 2% was found after MD steps using the single precision version of GROMACS (which is the default) [\cite=Lippert2007].

For our GPU and host implementations using both single and double precision, we have examined the evolution of the total system energy, displayed in Fig. [\ref=fig:energy_conservation]. In addition, we compare the degree of energy conservation for WCA and LJ potentials with and without smoothing and for two different time steps. The single precision GPU implementation shows a clear drift of about 0.1% per MD steps for both potentials (panels a and b). There is a contribution from the c.m. velocity drift, which is, however, orders of magnitude smaller. Smoothing the potentials at the cutoff does not improve energy conservation here. For the WCA potential, the time step δt* = 0.003 is obviously too large; energy conservation is considerably more degraded if the potential is smoothed. Using double-single precision for the summation of forces and in the velocity-Verlet algorithm (panels d and e) reduces the energy drift by factors of about 3 (LJ potential) to 7 (WCA). Additional smoothing of the potentials, however, improves energy conservation significantly by an extra order of magnitude. Thereby, the drift is almost eliminated in the case of δt* = 0.001 down to and per steps for the WCA and the LJ potential, respectively. Such a tiny drift, however, is dominated and obscured by numerical fluctuations.

The host simulation results shown in panels c and f undermine that the degradation of energy conservation due to single precision is not specific to the GPU implementation. While the quantitative evolution of the energy in panels e and f differs due to the implementation of floating-point arithmetic in either 44-bit double-single precision (GPU) or native 53-bit double precision (CPU), the orders of magnitude of energy conservation are comparable.

Numerical energy fluctuations

The analysis of the numerical energy fluctuations yields a sensitive test of the numerical accuracy which requires only short simulation runs. Newton's differential equations are discretised by the velocity-Verlet algorithm to first order in the time step δt, introducing a discretisation error of order δt2--provided the potential possesses a continuous second derivative. Thus, one expects that the total energy shows numerical fluctuations around its initial value which scale as δt2. In particular, /  δt2 should roughly be independent of the time step.

For time steps between δt* = 0.001 and 0.005, these rescaled energy fluctuations are displayed in Fig. [\ref=fig:energy_fluctuations] for the LJ potential. Using double-single precision on the GPU, all five curves nicely collapse (panel d) over the range of 200 to 1000 integration steps. Merely the largest time step, δt* = 0.005, is slightly off, indicating that higher order terms become relevant in this case. Smoothing the potential at the cutoff improves the collapse, from which small time steps benefit especially (panel e). If only single precision arithmetic is used on the GPU, the collapse is poor and smoothing the potential at the cutoff has essentially no effect (panels a and b). The two smallest time steps are completely off, which we attribute to the quick accumulation of rounding errors from the tiny increments.

For comparison, we have added the results from the host implementation in single and double precision (panels c and f). The almost identical behaviour as on the GPU corroborates that the discussed effects are due to the limited precision only, and no other numerical artifacts are introduced by the GPU. An insignificant, but nevertheless interesting difference between the GPU (double-single precision) and the CPU (double precision) results are the high-frequency fluctuations visible at the smallest time step δt* = 0.001 for the GPU case (panels d and e). These tiny fluctuations are caused by the evaluation of the individual pair force contributions in single precision. We verified that the high-frequency fluctuations disappear if the entire force algorithm on the GPU is implemented in double-single precision at the cost of significantly reduced performance.

Application to glassy dynamics of a supercooled liquid

We employed the above GPU implementation of a molecular dynamics simulation to reproduce the slow dynamics of a supercooled liquid of soft spheres. We resorted to the Kob-Andersen (KA) binary mixture [\cite=Kob1994] [\cite=Kob1995] [\cite=Kob1995b], which has proven to be a useful model system that reliably delays crystallisation. Specifically, we have investigated a relatively large system of 40,000 A and 10,000 B particles of equal masses m interacting with Lennard-Jones potentials, [formula] with the parameters chosen as in Ref. [\citealp=Kob1994]: σAA = 1, σBB = 0.88, σAB = 0.8, εAA = 1, εBB = 0.5, and εAB = 1.5. The time step of the Verlet integrator was taken to be δt* = 0.001 in units of [formula]. Equilibration runs were done for fixed energy and covered about 10 times the structural relaxation time; all results were obtained for two independent systems with different initial conditions. Production runs of to steps (for T* = 0.60 and 0.43, respectively) including the online evaluation of the correlation functions merely took between 1.4 hours and 9.6 days of real time.

For the following discussion, we need some basic quantities central to the description of glassy dynamics. The simplest quantity to characterise the transport dynamics is the mean-square displacement (MSD) [formula], where [formula] denotes a microcanonical time average and [formula] an average over all particles, [formula]. Here, we restrict the discussion to A particles. The diffusion constant D of a tagged particle is then obtained via δr2(t)≃6Dt for t  →    ∞  . A more complex quantity is the time-correlation function of local density fluctuations, the intermediate scattering function (ISF). The self-part of the ISF is defined as [formula] using the Fourier components of the tagged particle density, [formula], with discrete wavenumbers [formula] and [formula] denoting any of the [formula]. Rotational symmetry implies that [formula] merely depends on the magnitude of the wavevector [formula], and additional averaging can be done over the orientation of [formula]. To quantify the structural relaxation time τα, we adopt the usual definition [formula], where [formula] denotes the maximum of the structure factor.

The MSD develops a pronounced plateau for decreasing temperature, reflecting the caging by the arrested surroundings; see Fig. [\ref=fig:msd+isf]a. The diffusion coefficient is drastically suppressed as the temperature approaches an anticipated glass transition temperature Tg and spans more than 3 decades over the simulated temperature range. Correspondingly, the density correlators shown in Fig. [\ref=fig:msd+isf]b develop a plateau, which is a signature of the structural arrest. The slow dynamics is quantified by the diverging structural relaxation time τα, for which we observe an increase by 4 orders of magnitude.

A clear observation of the glassy dynamics requires sufficient separation between short-time features and the slow structural relaxation. Hence, the temperature has to be fine-tuned close to the transition, presupposing a sharp value for Tg. Moreover, simulation runs become very long and the energy of the system must be extremely stable during a complete run; we could limit the energy drift to merely over MD steps at T* = 0.43. It turns out that such a long-time stability cannot be maintained with single floating-point precision. For low temperatures T* = 0.43,0.44,0.46,0.48, we have performed additional production runs with single precision, and both the MSD and the density correlators deviate significantly at long times, see Fig. [\ref=fig:msd+isf] (broken lines). The system heats up during the simulation, which introduces physical artifacts in the form of a faster relaxation at the pretended temperature. The determined diffusion constants and structural relaxation times for both levels of precision are compared in Table [\ref=tab:diffusion+tau_alpha], revealing quantitative differences of up to 41%. At the lowest investigated temperature, the system appears to become even super-diffusive at long times; note the crossing of the MSD curve at T* = 0.43 obtained with single precision and the one at T* = 0.44 using double-single precision in Fig. [\ref=fig:msd+isf]a.

Further, the use of current graphics processors facilitates the investigation of much larger system sizes than were usually accessible before. Among other benefits, data quality is enhanced as statistical fluctuations of tagged particle quantities are expected to scale as [formula]. First results for the velocity autocorrelation function display an excellent signal-to-noise ratio and shed light on novel power-law correlations at low temperatures [\cite=Glassy_VACF:2010].

Conclusion

We have shown how recent graphics processing units can be harnessed to carry out large-scale molecular dynamics simulations in the microcanonical ensemble with strict energy conservation even after MD steps. Using GPU computing, we were able to reproduce the slow glassy dynamics of a binary Lennard-Jones mixture over 4 nontrivial decades in time. Single floating-point precision, however, is not sufficient for this purpose and may result in qualitatively and quantitatively wrong results; e.g., the diffusion coefficient was found to diverge at T* = 0.43 and to deviate by up to 40% at higher temperatures due to the limited energy conservation. We have shown that the mediocre native double precision performance of recent GPUs can be overcome by implementing numerically critical parts of the MD algorithm with double-single precision floating-point arithmetic, which is based on single precision instructions.

The described MD simulation package is fully implemented on the GPU using CUDA, and it avoids costly memory transfers of trajectory data between host and GPU. In addition to earlier work [\cite=Meel2008] [\cite=Anderson2008], the sorting of particles in memory and the evaluation of dynamic correlation functions are completely performed on the GPU. The number of simulated particles is solely limited by the amount of global device memory. On the NVIDIA GeForce GTX 280 providing of memory, simulations of 864,000 particles are possible, but the barrier of one million particles is broken on the NVIDIA Tesla C1060 with of (somewhat slower) memory. Our performance measurements show speedups of 70 to 80 compared to a serial simulation on the host processor, and we have shown that the GPUs we have deployed perform similarly to LAMMPS on a modern, conventional HPC system running in parallel on 64 processor cores. We have found that the use of double-single precision in specific parts of the algorithm increases the execution times by merely 20%, which we attribute mainly to a doubling of memory accesses. While the use of native double precision arithmetic in the next generation of GPUs will reduce the number of floating-point operations compared to double-single precision, we expect that the performance penalty due to the latency of global memory access will remain. In particular, the trade-off between performance optimisation and numerical accuracy in terms of floating-point precision will persist for GPUs as it does for conventional processors.

In summary, current graphics processors provide a powerful and robust means for state-of-the-art simulations of simple and complex liquids in general and for numerical studies on glass-forming liquids in particular. Substantial computing resources can be delivered already by local GPU clusters containing a few dozen high-end GPUs, which are affordable in terms of acquisition cost and maintenance for a single institute and which are likely to play a considerable role in future simulation-based research. In addition, some national computing centres have started to support GPU-accelerated computing on large dedicated GPU clusters, which are useful at the single-GPU level already. They will, however, be fully exploited only by the further development of simulation packages running on distributed GPUs (see Refs.  for examples), enabling the routine investigation of large and complex systems that can be studied today on exceptionally few supercomputers only.

Acknowledgment

We thank Thomas Franosch and Jürgen Horbach for many helpful discussions and Erwin Frey for generous support. F.H. acknowledges financial support from the Nanosystems Initiative Munich (NIM). The described software, HAL's MD package, is licensed under the GNU General Public License and is freely available at the project's website [\cite=Colberg2009].