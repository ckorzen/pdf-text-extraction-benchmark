Reversibility in Massive Concurrent Systems

Reversing a (forward) computation history means undoing the history. In concurrent systems, undoing the history is not performed in a deterministic way but in a causally consistent fashion, where states that are reached during a backward computation are states that could have been reached during the computation history by just performing independent actions in a different order. In rccs, Danos and Krivine achieve this by attaching a memory m to each process P, in the monitored process construct m:P. Memories in rccs are stacks of information needed for processes to backtrack. Alternatively, Phillips and Ulidowski propose a technique for reversing process calculi without using memories. In this technique, the structure of processes is not destroyed and the progress is noted by underlining the actions that have been performed. In order to tag the communicating processes, they generate unique identifiers on-the-fly during the communications.

These foundational studies of reversible and concurrent computations have been largely stimulated by areas such as chemical and biological systems - called massive concurrent systems in the following - where operations are reversible, and only an appropriate injection of energy and/or a change of entropy can move the computational system in a desired direction.

However there is a mismatch between chemical and biological systems and the above concurrent formalisms. In the latter ones, reversibility means desynchronizing processes that actually interacted in the past while, in massive concurrent systems, reversibility means reversibility of configurations. In order to make massive concurrent systems reversible with the process calculus meaning, one has to remember the position and momentum of each molecule, which is precisely contrary to the well-mixing assumption of biochemical soups, namely that the probability of collision between two molecules is independent of their position (cf. Gillespie's algorithm).

To comply with the well-mixing assumption, notions of causality and independence of events need to be adapted to reflect the fundamental fact that different processes of the same species are indistinguishable. Their interactions can cause effects, but not to the point of being able to identify the precise molecule that caused an effect. We introduce an algebra for massive concurrent systems, called reversible structures, and, following LÃ©vy, we define an equivalence on computations that abstracts away from the order of causally independent reductions - the permutation equivalence. Because of multiplicities this abstraction does not always exchange independent reductions. For example, two reductions that use a same signal cannot be exchanged because one cannot grasp whether the two reductions are competing on a same signal or are using two different occurrences of it. Notwithstanding this inadequacy, permutation equivalence in reversible structures yields a standardization theorem that allows one to remove converse reductions from computations.

Reversible structures may implement significant ccs-style interaction patterns (Cardelli already noticed this by studying a class of reversible systems - the dna chemical systems). Consider for example a binary operator that takes two input molecules and produces one unrelated output molecule when (and only when) both inputs are present. It is too difficult to engineer the input machinery in order to any possible pattern of interaction, and to produce the output molecule out of their own structure. This operator is therefore implemented by an artifact that binds the two inputs one after the other and then releases the output out of its own structure. Of course, if the second input never comes it must release the first input, because the first input may be legitimately used by some other operator. This means that the binding of the first input must be reversible, and the natural reversibility of reversible structures is exploited to achieve the correctness.

In order to bridge the gap between reversible process calculi and massive concurrent systems, we consider reversible structures where multiplicities are dropped (terms have multiplicity one) - the coherence constraint. Coherence in this strong sense is not realizable in well-mixed chemical solutions, but may become realizable in the future if we learn how to control individual molecules. We demonstrate that coherent reversible structures implement the asynchronous fragment of rccs.

The exact distance between coherent and uncoherent reversible structures (that is, between reversible process calculi and massive systems) is manifested by the computational complexity of the reachability problem (verifying whether a configuration is reachable from an initial one). We demonstrate that reachability in coherent reversible structures has a computational complexity that is quadratic with respect to the size of the structures, a problem that is expspace-complete in generic structures.

Our study prompts a thorough analysis of reversible calculi where processes have multiplicities and the causal dependencies between copies may be exchanged. Open questions are (i) What synchronization schemas can be programmed in massive concurrent systems? (ii) Are there other constraints, different than coherence, such that relevant bio-chemical properties retains better algorithms than in standard structures? (iii) What is the theory of massive (reversible) systems with irreversible operators and what is the relationship with standard programming languages?