GOTHIC: Gravitational oct-tree code accelerated by hierarchical time step controlling

Introduction

Collisionless N-body simulations are frequently employed to investigate large scale structure formation and the formation and evolution of gravitational many-body systems such as galaxies. The acceleration of N-body particles is given by Newton's equation of motion,

[formula]

where mi, [formula], and [formula] are the mass, position, and acceleration of the i-th particle of N particles, respectively. The remaining symbols are the gravitational constant G and the Plummer softening parameter ε. The latter is commonly adopted in collisionless N-body simulations to eliminate divergence due to division by zero. Hereafter, we call the particles which feel and cause gravitational force as i- and j-particles, respectively, and denote their total numbers Ni or Nj.

Employing a large number of N-body particles is essential for performing N-body simulations that resolve astrophysical phenomena. Since the computational cost of order O(NiNj) is too high to investigate realistic phenomena in detail, many earlier studies have attempted to accelerate N-body simulations. Widely used algorithms for reducing the amount of computations are the particle-mesh method and the tree method [\citep=HockneyEastwood1988] [\citep=BarnesHut1986]. The computational complexity of the tree method is O(Ni log Nj) because the multipole expansion technique significantly reduces the contribution from j-particles.

Many N-body simulations adopt a shared time step, and that means all N-body particles share the time step that is required to track the orbital evolution of the particle that evolves its physical quantities in the shortest time span. The timescale of the evolution is not uniform in most astrophysical phenomena; for example, the free-fall time, which is a measure for the timescale of evolution due to self-gravity, scales as the inverse square root of the mass density, and the mass densities have order-of-magnitude differences in typical systems. Therefore, adopting a shared time step causes unnecessary, additional computations to track the evolution of the system. To overcome the situation, a scheme in which every N-body particle has their own individual time step was introduced by [\citet=Aarseth1963]. Because individual time steps for all particles is not suitable for parallelization, [\citet=McMillan1986] proposed the use of block time steps (or sometimes called hierarchical time steps) in which a group of particles has the same time step. Adopting block time steps can reduce the number of computations by reducing Ni.

Exploiting accelerator devices is another approach to reducing the time-to-solution. In the field of numerical astrophysics, a famous accelerator for N-body simulations is the GRAPE ("GRAvity PipE") series [\citep=GRAPE] [\citep=GRAPE1] [\citep=GRAPE2] [\citep=GRAPE2A] [\citep=GRAPE1A] [\citep=GRAPE6A] [\citep=GRAPE3] [\citep=GRAPE4] [\citep=GRAPE6] [\citep=GRAPE5] [\citep=FIRST]. Its high performance is a result of the pipelined and massively parallel architecture design, which enables massive parallelization of gravitational force calculations. Another widely used accelerator device is the Graphics Processing Unit (GPU), which was originally developed as a processor dedicated to image processing, and is equipped with a large number of computing units (typically a few hundred to a few thousand), suitable for parallel computing. The memory architecture of GPU mainly consists of shared memory and global memory: the former is fast and small on-chip memory (~  1 MB per GPU), and the latter is slow and large off-chip memory (~  1-10 GB per GPU, but about 100 times slower than the shared memory). Rapid performance improvement of GPUs and the development of General Purpose computing on GPU (GPGPU) have elevated GPUs to be the most attractive accelerators. Moreover, recent demands for power efficient devices strongly support the rapid development of accelerator devices such as GRAPE, GPU, and Intel Xeon Phi.

To promote GPU computing, NVIDIA provides the C/C++ like programming environment named Compute Unified Device Architecture [\citep=CUDA1.0Manual] [\citep=CUDA7.5Manual]. CUDA helps programmers implement GPU codes and optimize them by abstracting actual management of GPU cores and hiding differences among GPUs of various generations. For example, an essential building block of the Fermi generation GPUs is the streaming multiprocessor (SM), which is a group of 32 CUDA cores. In the Kepler generation of GPUs and Maxwell generation of GPUs SM are called SMX and SMM, respectively, and have 192 or 128 CUDA cores. For simplicity, we will refer to this fundamental group of CUDA cores as SM, irrespective of the GPU's generation. The fundamental parallelism in CUDA is thread parallelism, and a bunch of threads is called a block (typically 128-512 threads). Also, a group of blocks is called a grid; the hierarchical structure composed of the thread, block and grid is a key concept in CUDA. CUDA assigns multiple blocks to an SM for hiding latency to access memory and switch threads effectively. Since, in most applications, the number of threads per SM is sufficiently large compared to the number of CUDA cores per SM, all we have to do is to determine the number of threads per block. Through such abstractions of programming and the achieved high performance, GPU computing is now an important domain in high performance computing (HPC) community.

Many earlier studies showed that the tree method efficiently works on GPU(s) [\citep=Nakasato2012] [\citep=Ogiya2013] [\citep=Bedorf2012] [\citep=Bedorf2014] [\citep=WatanabeNakasato2014]. However, none of the studies have coupled their tree method with the block time step on GPU. One difficulty when coupling the block time step with the tree code running on GPU is maintaining performance in the low Ni-regime. As mentioned above, the reduction of the time-to-solution by the block time step is due to the decrease of Ni. However, the performance of massively parallel architectures always drops in the low-number limit because only some of the cores perform any computations while others do not, leading to a waste of computing resources. In the typical implementation of a direct N-body code running on GPU, the critical number of particles required in order not to waste CUDA cores is 104 [\citep=Miki2012] [\citep=Miki2013]. A viable method to decrease the critical number is to adopt ij-parallelization [\citep=Nitadori2006] [\citep=Nyland2007] [\citep=Miki2012], by which multiple processors calculate the force on a common particle. [\citet=Miki2012] showed that ij-parallelization can sustain the high performance of their direct N-body code down to N  ~  103 on NVIDIA Tesla C2070. An option to activate ij-parallelization may increase the performance of tree code on GPU that adopts the block time step.

In GPU computing, a bunch of threads, 32 threads in the case of CUDA called a warp, always execute the same operation concurrently. If two threads in a warp are forced to execute different operations due to conditional branching, then the threads run both operations. Since there are 32 threads in a warp, this behavior, named "warp divergence", may cause up to 32 times slow down of calculations in the worst case. Therefore, avoiding the warp divergence is one of the key strategies to accelerate calculations using GPU. In the tree code runs on GPU, [\citet=Ogiya2013] proposed an algorithm that reduces the warp divergence within the tree traversal and showed it improves the performance. On the other hand, concurrent operations by 32 threads present an opportunity to remove explicit synchronizations within a warp because they are implicitly synchronized. Synchronization is an inevitable operation for parallel computing to proceed properly; however, it often hinders achieving high performance. Hence, removing explicit synchronizations recovers high performance in parallel computing and reduces the time-to-solution. In N-body simulation with direct summation, [\citet=Miki2012] demonstrated the benefits of removing explicit synchronizations, especially in the low N runs, where the contribution from synchronization grows.

There is further room for accelerating N-body simulations through automatic performance tuning (auto-tuning). Several examples of auto-tuning accelerating software libraries have been developed in the HPC community [\citep=Whaley2001] [\citep=FrigoJohnson2005]. The primary purpose of auto-tuning is to provide performance portability on various architectures and to benefit from the rapid performance improvements of architectures without needing to significantly modify optimized codes. Another essential objective of auto-tuning is to ensure the high performance of the code irrespective of input. For example, the performance of sparse matrix-vector multiplications (SpMV) on GPU has a strong dependence on the input sparse matrix [\citep=BellGarland2008]. Many studies showed the benefits of auto-tuning for SpMV [\citep=RegulyGiles2012] [\citep=Ashari2014] [\citep=LiuVinter2015] [\citep=MaggioniBerger-Wolf2016]. In astrophysics, [\citet=Ishiyama2009] [\citet=Ishiyama2012] achieved a good load balance for their massively parallel TreePM code by incorporating on-the-fly measurements for the execution time of each function within the simulation. Just like SpMV, the time-to-solution of the tree method are dependent on the initial data because the particle distribution determines the total number of calculated interactions. Introducing some adaptive features to the tree code would contribute to accelerating N-body simulations by reducing slowdowns in the computation due to the non-uniform particle distribution.

These considerations drove us to develop and test a tree code adopting a block time step that runs on GPU. The name of the code is GOTHIC (Gravitational Oct-Tree code accelerated by HIerarchical time step Controlling). The remainder of this paper is organized as follows. Section [\ref=sec:implementation] introduces the implementation and optimizations of GOTHIC using CUDA. Section [\ref=sec:results] presents results of performance measurements, and Section [\ref=sec:discussion] contains discussions. Finally, Section [\ref=sec:summary] summarizes this work.

Implementation

This section describes our strategy, implementation, and optimizations in detail. In GOTHIC, all instructions are performed on GPU, just like Bonsai [\citep=Bedorf2012] [\citep=Bedorf2014] to minimize communication between CPU and GPU. Also, all floating-point operations are performed in single precision because this provides sufficient accuracy to follow the time evolution of collisionless systems. Section [\ref=sec:implementation:makeTree] explains how to construct tree structure on GPU, and Section [\ref=sec:implementation:walkTree] presents the algorithm to calculate the gravitational force adopted in GOTHIC. Sections [\ref=sec:implementation:splitGroups] and [\ref=sec:implementation:ij.parallelization] introduce additional optimizations aiming to keep performance even in situations not suitable for GPU. Section [\ref=sec:implementation:rebuildInterval] gives information on further optimization to reduce the time-to-solution of GOTHIC, rather the execution time of a specific function. Sections [\ref=sec:implementation:MAC] and [\ref=sec:implementation:integrator] present other information required to implement a tree code, and Section [\ref=sec:implementation:kepler] shows additional tips and issues related to the Kepler generation GPUs.

Generating Tree Structure

The space-filling curve based construction of the tree structure, which represents the particle distribution as a logical structure, is performed by the GPU. In this study, we adopt the Peano-Hilbert space-filling curve [\citep=Sagan2012] to exploit its one-stroke sketch nature, which the more familiar Morton curve does not have. First, the GPU generates the Peano-Hilbert key for all N-body particles in the global memory of the device (see [\ref=sec:appendix:space.filling.curves] for more details). Then, the N-body particles are sorted according to the Peano-Hilbert space-filling curve by using cub::DeviceRadixSort::SortPairs function provided in CUB v1.5.1. Using the Peano-Hilbert curve guarantees that the particles near one another in memory space are also near one another in physical space. The relation between memory space and physical space is important when optimizing codes, as shown by [\citet=Ogiya2013] for accelerating gravity calculations using the tree structure.

Next, the GPU links the Peano-Hilbert key with the tree structure. The Peano-Hilbert space-filling curve itself has a hierarchical structure. Dividing a cube into eight sub-cubes (i.e., generating an octree structure) corresponds to dividing the Peano-Hilbert key into eight equal parts (or finding seven partitions of the Peano-Hilbert key). Because increasing parallelism is essential to accelerating calculations using many-core architectures such as GPU, we construct the tree structure in a breadth-first manner. Checking multiple tree cells in parallel is possible. However, child cells of all checked cells must have serial numbers to identify them. Calculating prefix sums [\citep=Blelloch1990] is necessary to tag all tree cells consistently.

When calculating prefix sum within a warp in parallel, the implicit synchronization of 32 threads is an important feature to exploit. Since the warp shuffle instruction is available in GPUs starting with the Kepler generation, our implementation of parallel prefix sum calculation within a warp utilizes the warp shuffle instruction on the Kepler and Maxwell generation GPUs or the shared memory on the Fermi generation GPUs. Repeated executions of a parallel scan within a warp with the appropriate use of __syncthreads() and shared memory yield parallel prefix sums within a block. To implement parallel prefix sums within a grid, global synchronization of multiple blocks within a grid is necessary. GOTHIC adopts the GPU lock-free synchronization proposed by [\citet=XiaoFeng2010] as a global synchronization mechanism. In the algorithm, all blocks within a grid must run simultaneously so as not to cause a deadlock. The __launch_bounds__ qualifier is useful to control the number of concurrent blocks in the case that the register usage limits the number of concurrent blocks per SM. Also, cudaFuncAttributes::numRegs obtained by calling the cudaFuncGetAttributes function is helpful to judge whether the deadlock will occur just before calling the device function.

Since GOTHIC adopts the monopole approximation for gravity calculation between an i-particle with a tree cell, introducing imaginary particles corresponding to tree cells can simplify the implementation of the function to calculate the gravitational force. After the Peano-Hilbert keys are associated with the tree structure, the GPU generates imaginary particles called pseudo j-particles and connect them with tree cells. The pseudo j-particle has information on mass mJ, position [formula] and the size bJ; hereafter, the capitalized subscript indicates the index of the pseudo particles. The mass is the total mass of real N-body particles contained in the corresponding tree cell and the position is the center-of-mass of the particles. The size of the pseudo j-particle is defined as the radius of a sphere centered on [formula] which can contain all N-body particles contained in the tree cell (see Fig. [\ref=fig:pseudo.j-particle]). All physical quantities of the pseudo j-particles must be recalculated at every time step to calculate gravitational force properly.

Multipole Acceptance Criterion

If a pseudo j-particle is far, then the gravity from the particle is calculated; if it is near, the tree cell is restricted to the lower level. To judge whether a pseudo j-particle is near or far, the Multipole Acceptance Criterion (MAC) is employed. The most simple MAC is opening angle criterion proposed by [\citet=BarnesHut1986]:

[formula]

where diJ is the distance to the particle from an i-particle and θ is an accuracy controlling parameter.

Because the above MAC cannot directly control the accuracy with which the gravitational forces are calculated, more sophisticated MACs have been proposed. The MAC proposed by [\citet=WarrenSalmon1993] [\citet=SalmonWarren1994] is as follows:

[formula]

where [formula] is an accuracy controlling parameter and

[formula]

The MAC defined by Eq. ([\ref=eq:implementation:MAC:WS93]) ensures the required accuracy by monitoring the truncation error of the multipole expansion.

In addition, the acceleration MAC by [\citet=Springel2005] given by

[formula]

also gives the required accuracy, where [formula] is the acceleration of the i-particle in the previous time step and [formula] is an accuracy controlling parameter. This MAC directly monitors the acceleration of each i-particle, and gives the appropriate accuracy of the acceleration specified by [formula].

The best choice of MAC from the three above must be determined by experiments. In the case of a tree code running on CPU, [\citet=Nelson2009] compared the elapsed time of each MAC as a function of achieved accuracy, and concluded that the acceleration MAC was the optimal choice. The performance of the MAC, however, should depend on the implementation of the function which calculates the gravitational acceleration and is optimized for a specific architecture, in our case, GPU. Comparing MACs is, therefore, still necessary for tree codes optimized for GPU and we will provide results of the comparison in §[\ref=sec:results:time].

Traversing Tree Structure

Increasing arithmetic intensity leads to performance improvements since hiding the latency to access global memory becomes much easier. To increase the arithmetic intensity in the kernel function, [\citet=Ogiya2013] introduced the technique of "vectorization". [\citet=Ogiya2013] adopted the depth-first search on-the-fly and the number of i-particles per thread is assumed to be [formula]. When judging whether the distance to a pseudo j-particle is far or near, they calculate the distance between the pseudo j-particle and [formula] i-particles one by one. A minimum of [formula] evaluations of distance is used for the distance judgment. The total number of interactions increases due to the minimum of [formula] evaluations; therefore, [formula] has some optimal value determined by balancing pros and cons of the effects by the vectorization.

During tree traversal when calculating the gravitational force, warp divergence occurs when some threads in a warp judge the distance to a pseudo j-particle to be sufficiently far while the remainder judge the distance to still be near. [\citet=Ogiya2013] introduced "grouping" to reduce the warp divergence. In this step, they group the distance judgment into [formula] threads ([formula] must be smaller than 32 to utilize the implicit synchronization within a warp) by sharing the minimum distance to a pseudo j-particle from [formula] i-particles in [formula] threads. Just like [formula], there is also an optimal value of [formula].

In [\citet=Ogiya2013], [formula] distance calculations by [formula] threads and [formula] comparisons to group the judgement in [formula] threads are required to judge whether a specific pseudo j-particle is near or far. Here, we modify the vectorization method proposed by [\citet=Ogiya2013] by using a breadth-first search. The vectorization in the original form requires [formula]-times Ni particles for sustained performance. This diminishes the benefits of the block time step. Therefore, we adopt a compromise between an on-the-fly method and an interaction list method. In this method, a small sized interaction list is created in shared memory. Once the size of the interaction list reaches a certain predefined value, we calculate gravitational forces between i-particles and pseudo j-particles in the list and clear the list. By repeating the procedure, the gravity by all j-particles is properly calculated. The arithmetic intensity of the kernel function is determined by the capacity of the interaction list, which depends on the number of threads per block and the cache configuration of the shared memory.

To use the shared memory efficiently and reduce warp divergence, we adopt the grouping almost in the original form. Grouping the interaction list of [formula] threads leads to a [formula] times bigger list to be stored in the shared memory. We modify the algorithm for grouping the distance judgment to remove [formula] comparisons as follows. Since the breadth-first search can access queued tree cells in parallel, distance evaluations to multiple pseudo j-particles can be performed at the same time. We introduce a pseudo i-particle shared by [formula] threads as shown in Fig. [\ref=fig:pseudo.i-particle]. The pseudo i-particles is to include all corresponding real i-particles by defining the appropriate radius bI. There is some freedom in defining the center of the enclosing sphere [formula]: for example, the center of the smallest enclosing ball, the center-of-mass of real i-particles, or the geometric center of the enclosing rectangular cuboid (see [\ref=sec:appendix:enclosing.balls] for more detail). The optimal choice to minimize the elapsed time of GOTHIC will be determined in §[\ref=sec:results:configuration] to provide the shortest elapsed time in micro-benchmarks. The distance between the pseudo i-particle and a pseudo j-particle is evaluated as the distance between an imaginary particle and the pseudo j-particle. The imaginary particle is set at the intersection of the surface of the pseudo i-particle with a line connects the pseudo i-particle with the pseudo j-particle, [formula]:

[formula]

where

[formula]

Introducing the pseudo i-particle is functionally the same as the vectorization and the grouping by [\citet=Ogiya2013] because the distance between the pseudo i-particle and the j-particle is always smaller than that between all corresponding i-particles and the j-particle.

When traversing the tree structure in a breadth-first manner, many tree cells must be stored in a large buffer compared to one child cell stored under the depth-first search. The breadth-first search requires additional global memory allocation. Because the total capacity of the global memory on GPU is limited (e.g., 5 GB for NVIDIA Tesla M2090 and K20X with ECC enabled), sophisticated memory management is necessary. In order to allocate as large as possible a chunk of global memory for the buffer, we first query the unused capacity of the global memory using the cudaMemGetInfo() function and then allocate the buffer in the global memory. The next problem is the assignment of the buffer to each thread-block. In this study, the capacity of the shared memory sets the upper limit on the number of thread-blocks per SM to two. It determines the maximum number of thread-blocks which can run simultaneously, and we equally divide the buffer into the given number of pieces. The special register %smid acquired by the inline PTX function tells the ID of SMs, and is useful to assign unused parts of the buffer to a running thread-block. It should be noted that %smid is a volatile variable. Thus, a careful treatment is required to occupy and release the partitioned buffer correctly.

Splitting Particle Groups in Low Dense Region

One of the shortcomings of the method introduced in §[\ref=sec:implementation:walkTree] is an over-computation when i-particles in a low dense region are selected as a group of i-particles. To avoid this situation, we introduce a critical separation [formula] to judge whether to unify i-particles into a group or not. If the value is too large or too small, then the elapsed time will become longer due to over-computation or over-splitting of the kernel, respectively. The critical separation [formula] must be set carefully to minimize the elapsed time; however, it is impossible to determine the optimal value before the calculation because [formula] depends on the particle distribution which evolves in the simulation. This leads us to set [formula] through trial-and-error during the simulation. In other words, we apply auto-tuning to determine the optimal value of [formula]. The strategy we adopt is to search for the optimal [formula] by minimizing the GPU time to calculate gravity using Brent's method [\citep=Press2007] and treating the GPU time as a function of [formula]. Since the optimal value of [formula] would also depend on time, some perturbation on [formula] is additionally introduced. According to this scheme, [formula] automatically evolves to reduce the elapsed time.

Increasing Parallelism in Gravity Calculation

Maintaining the high performance of the code down to the low Ni-regime is an essential point to achieve high performance with the block time step. However, this is difficult because a lack of parallelism reduces the GPU performance by wasting CUDA cores. The critical number of particles to saturate GPU performance is 104 in the case of direct N-body calculation [\citep=Miki2012] [\citep=Miki2013]. Some remedy should be introduced to limit the performance decrease in low Ni-regime. A straightforward remedy is introducing ij-parallelization to increase parallelism [\citep=Nitadori2006] [\citep=Nyland2007] [\citep=Miki2012]. In the case of ij-parallelization, multiple threads share an i-particle and calculate gravity to the particle. As a result, we regain running CUDA cores and GPU performance even in the low Ni-regime.

Introducing ij-parallelization requires an implementation of a force accumulation process among multiple threads that share a common i-particle. In this work, we have implemented an essentially identical version of the algorithm proposed by [\citet=Miki2012]. In principle, either synchronization or exclusive control or both are inevitable to sum up the threads' results, and this always impedes the performance improvement in parallel computing. [\citet=Miki2012] proposed an algorithm specialized for GPU computing to alleviate the burden of the force accumulation process. They remove explicit synchronization of multiple threads by aggressively utilizing the specification of CUDA that 32 threads in a warp always perform the same operation (implicit synchronization). Therefore, the number of threads that share an i-particle, S, must satisfy S  ≤  32.

Tree Rebuild Interval

The cost of tree construction, [formula], is not negligibly small compared to that of tree traversal, [formula], and there is no requirement to rebuild the tree structure every time step. Since the particle distribution is almost the same for two time steps in succession, reusing the old tree structure will not deteriorate [formula] without additional cost to rebuild the tree structure. The mismatch between the tree structure and the actual particle distribution would increase the execution time, and the timescale of the increase is a function of the time evolution of the particle distribution. There ought to be an optimal interval to rebuild the tree structure and finding it is a task suited to auto-tuning.

The code determines the rebuild interval n by guessing the total elapsed time [formula]. The total elapsed time between the tree constructions is given by

[formula]

where [formula] is the execution time to calculate gravity in the i-th step out of n steps which use the same tree structure.

Here, we introduce three toy models, a linear growth model, a power-law growth model, and a parabolic growth model, to guess [formula]. In the first model, we assume [formula] grows as

[formula]

where t1 and [formula] are intercept and slope, respectively. The above fitting parameters are determined using the least squared method by monitoring the execution time in every time steps. Then, the total elapsed time is estimated as

[formula]

To minimize the mean execution time [formula], differentiate [formula] with respect to n:

[formula]

Therefore, the condition to get the extremum is

[formula]

Furthermore, the second derivative with respect to n is evaluated as

[formula]

and is always positive meaning that Eq. ([\ref=eq:implementation:rebuildInterval:optimal.condition.in.linear.growth.model]) always minimizes the mean execution time.

The power-law and the parabolic growth models are shown in [\ref=sec:appendix:rebuild.interval.modeling]. The model which gives the smallest reduced χ2 value,

[formula]

is the most appropriate of the three choices. The degrees of freedom ν is n  -  2 (for the linear or power-law growth model) or n  -  3 (for the parabolic growth model), and we simply assume σi is unity.

Orbit Integration

When the block time step is employed, every i-particle has its own time step. Since the adaptive, block time step is employed, we adopt a second-order Runge-Kutta method to integrate the particle orbit. In the prediction step, we update positions and velocities of all j-particles by

[formula]

[formula]

where [formula] is the velocity of the j-th particle at the n-th time step, subscripts and superscripts indicate the index of particles and time step, respectively. We then calculate gravity from all j-particles to selected i-particles, and execute the correction step for the chosen i-particles as

[formula]

Because the above predictor-corrector method is not a symplectic integrator, it does not conserve the pseudo-Hamiltonian unlike the leap-frog method often employed with the shared, fixed time step.

For the comparison cases where the time step is shared and fixed, we adopt a second-order leap-frog method. In this case, orbit integration is performed as

[formula]

[formula]

For fixed shared timesteps, the Runge-Kutta integrator reduces to the leap-frog method.

Note for Kepler generation GPUs

Kepler generation GPUs support more functions that are useful in performance optimization compared to Fermi generation GPUs. One is warp shuffle instructions, which enable reading registers in other threads within a warp without using the shared memory. Warp shuffle instructions are heavily exploited in the calculation of parallel prefix sums and reductions since it is faster than accessing registers via shared memory. The read-only data cache is another feature to be noted. Just adding the const __restrict__ qualifier tells the compiler to use a distinct cache in addition to L2 cache of the global memory. It effectively enlarges the capacity of cache and increases effective memory bandwidth.

A warp scheduler has two instruction dispatch units (IDUs) on Kepler generation GPUs [\citep=GK110Whitepaper] while it has only one IDU on Fermi generation GPUs [\citep=GF110Whitepaper]. The presence of multiple IDUs within a warp scheduler causes scheduling issues if subsequent operations within a warp have mutual dependencies. Furthermore, [\citet=LaiSeznec2013] reported that bank conflict of registers could occur among four banks on Kepler generation GPUs. Both the scheduling issue and bank conflict of registers cause a slowdown of operations on Kepler generation GPUs. Introducing instruction level parallelism can remove the dependency between subsequent operations and remove the scheduling issue created by multiple IDUs. We examined effects of increasing instruction level parallelism of multiple executions of fused multiply-add (FMA) instructions and direct N-body code without removing bank conflict of registers on NVIDIA Tesla K20. However, the performance did not improve; this suggests that a careful arrangement of registers to prevent bank conflicts is also necessary for further optimization. Because NVIDIA does not provide any tool or framework to arrange registers manually and CUDA shuffles locations of registers, we did not increase instruction level parallelism of subsequent computations or arrange locations of registers. Once such problems originated by hardware are resolved, we can expect the performance of GOTHIC to increase on Kepler or Maxwell generation GPUs.

Performance Measurements of the Code

Configuration of Measurements

Performance measurements were done on HA-PACS (Highly Accelerated Parallel Advanced system for Computational Sciences) and a workstation at the University of Tsukuba. HA-PACS is composed of two clusters: the Base Cluster (BC) and the Tightly Coupled Accelerator (TCA). HA-PACS/BC and HA-PACS/TCA is equipped with NVIDIA Tesla M2090 (Fermi generation GPU) and NVIDIA Tesla K20X (Kepler generation GPU), respectively. NVIDIA GeForce GTX TITAN X (Maxwell generation GPU) is installed on the workstation. Table [\ref=tab:results:configuration:environment] lists the detailed information of the measurement environments. All environments have multiple GPUs, but we use only a single board of GPU on each machine in the measurements below.

Fundamental parameters of the code (e.g., the number of threads per block for each kernel function) are determined by micro-benchmarks for a Navarro-Frenk-White (NFW) sphere [\citep=Navarro1995] [\citep=Navarro1996], a Plummer sphere [\citep=Plummer1911], a King sphere [\citep=Michie1963] [\citep=MichieBodenheimer1963] [\citep=King1966] and a Hernquist sphere [\citep=Hernquist1990]. All initial conditions used in this study are generated by the MAny-component Galactic Initial-conditions (MAGI) generator [\citep=MAGI]. Table [\ref=tab:results:configuration:kernel] summarizes the resultant configuration for functions related to the tree structure. Obviously, optimal values exist for each function (walkTree executes tree traversal, makeTree, linkTree, and trimTree build tree structure, calcMAC calculates physical quantities of pseudo j-particles, and genPHkey translates the position of an i-particle to a Peano-Hilbert key). The adopted enclosing ball for walkTree is the efficient bounding sphere [\citep=Ritter1990] on GTX TITAN X, while M2090 and K20X use the sphere centered on the geometric center of the enclosing rectangular cuboid.

Measured Elapsed Time

First, we investigated relations among the accuracy controlling parameters of three MACs (§[\ref=sec:implementation:MAC]), the resultant accuracy of gravity calculation and the elapsed time on various generations of GPUs. This is similar to the evaluation of a tree code performed by [\citet=Nelson2009]. Figure [\ref=fig:elapsed.time@NFW] shows the result in the case of an NFW sphere with 223  =   8,388,608 particles. The cutoff radii of the density profile and the length of the Plummer softening are 5rs and rs  /  64, respectively, where the scale length rs is set to unity. The elapsed time is evaluated as the wall clock time per time step (total number of time steps is fixed to 1024) to include the effects of auto-tuning; it also includes the time required to read/write files and allocate/deallocate memory. The accuracy of the gravity calculation is evaluated as a relative error of acceleration in the tree code [formula] compared to acceleration in the direct N-body code, [formula], where the subscript i indicates the index of the N-body particles. Upper and lower panels of the figure present the results for the 99 percentile error and median error, respectively. In other words, the points trace the loci at which 99% (50%) of N-body particles have a smaller error of the acceleration than the plotted value for each MAC in the upper (lower) panels. The figure clearly reveals the block time step (solid lines) is roughly twice as fast as the shared time step (dotted lines). The block time step with the acceleration MAC (red filled circles with solid line) has the shortest elapsed time in most cases. The multipole MAC (blue squares) is sometimes the optimal choice, especially with lower accuracy, and its performance with higher accuracy is comparable to that of the opening angle (black diamonds).

We have also compared the performance of GOTHIC with the public code Bonsai [\citep=Bedorf2012] [\citep=Bedorf2014] which runs on the Fermi and Kepler generation GPUs. On M2090, the performance measurement with θ  =  0.1 for Bonsai was not completed because the computation time was too long. In all cases, GOTHIC with acceleration MAC and block time step (i.e., fastest configuration) was faster than Bonsai except for the case for which the median force error was less than ~  10- 5 on K20X. The figure clearly shows that the improvements of GOTHIC with respect to Bonsai are more significant on M2090 compared to K20X. This was expected, because [\citet=Bedorf2014] performed sophisticated optimizations focused on the Kepler generation GPUs while we omit some optimizations (see §[\ref=sec:implementation:kepler]). In other words, the performance improvements of GOTHIC from Bonsai on the Kepler generation of GPUs would increase if we introduced optimizations highly focused on the Kepler generation of GPUs. The typical accuracy for N-body simulations on galactic scales is around 10- 3, which corresponds to a value of θ of 0.5-0.7. In such realistic parameter regions, GOTHIC is a few time faster than Bonsai on M2090.

The NFW sphere is not suitable for evaluating effects of the block time step owing to its simple density profile. A more complicated particle distribution having a wider dynamic range in the temporal domain of the orbit evolution of individual particles is be a better choice for performance measurements to examine effects of the block time step. In order to measure the performance in a realistic distribution, we generate a model of the Andromeda galaxy (M31). The mass distribution model of M31 is given by [\citet=Geehan2006] [\citet=Fardal2007]. Its composition is a dark matter halo with an NFW profile (the mass is 8.11  ×  1011 [formula] and the scale length is 7.63 kpc) with 7,730,866 particles, a stellar bulge with a Hernquist profile (the mass is 3.24  ×  1010 [formula] and the scale radius is 0.61 kpc) with 308,853 particles, and an exponential disk (the mass is 3.66  ×  1010 [formula], the scale length is 5.4 kpc, and the scale height is 0.6 kpc) with 348,889 particles. The total number of N-body particles is 223  =   8,388,608, the masses of all N-body particles are identical and the Plummer softening length is set to 16 pc. On M2090, a performance measurement with [formula] of 2- 19 for GOTHIC with the multipole MAC and the shared time step was not finished due to the limitation of the execution time on HA-PACS. Figure [\ref=fig:elapsed.time@M31] shows the results of the measurements. Again, the block time step with the acceleration MAC achieves the best performance in most cases. The performance gain of the block time step is significantly greater than that for a pure NFW sphere (Fig. [\ref=fig:elapsed.time@NFW]). This is because additional components (the bulge and the disk) make the density profile steeper. A steeper density profile means a wider range of time steps of N-body particles since the free-fall time, one of the typical time scales of the system, is proportional to the inverse square root of the volume density. Indeed, the number of time step levels increases from four for the NFW sphere to five for the M31 model. The block time step with the acceleration MAC (red filled circles) achieves the shortest elapsed time in most cases, and is always faster than Bonsai (green triangles). On M2090, the performance measurement with θ of 0.1 for Bonsai was not completed due to exceeding the maximum execution time on HA-PACS. Since the performance improvements from the shared time step are more significant compared to the pure NFW model, the speed increase of GOTHIC compared to Bonsai is greater in the case of the Andromeda galaxy model compared to the NFW model.

Benefits from Block Time Step

To assess benefits of adopting the block time step in detail, Fig. [\ref=fig:gain@M31] shows the speed up of the block time step from the shared time step in the case of M31. The block time step results in two times faster completion compared to the shared time in all cases. In galactic scale N-body simulations, the typical value for θ is 0.5-0.7. Corresponding values of [formula] and [formula] which give similar accuracy are from 2- 8 to 2- 6 and from 2- 5 to 2- 2, respectively (see Fig. [\ref=fig:elapsed.time@M31]). For such a typical accuracy, adopting a block time step results in about 2-5 times speed up for all three MACs on M2090, K20X, and GTX TITAN X. The amount of speed up tends to improve with increasing values of the accuracy-controlling parameters (i.e., the decreasing of the accuracy). When increasing the accuracy of gravity calculations, the number of calculations in high density regions increases because many particles are located near each other. Since the speed up of the block time step comes from the reduction of calculations in the low density regions, this increase in calculations weakens the benefits of adopting the block time step.

Hereafter, we regard the block time step with the acceleration MAC as a fiducial configuration, and go into more detail about the results from this configuration. Figure [\ref=fig:breakdown@M31] shows a breakdown of the execution time of various functions during the first 101 steps of the benchmark with [formula] on K20X. The initial condition of the system is a model of M31 in dynamical equilibrium with 223  =   8,388,608 particles. A slightly slow execution at the first step pushes back the first tree reconstruction to the 26th step; thereafter, the execution times of all functions settle into a regular repeating pattern because the system is in dynamical equilibrium. The execution time for calculating gravity (red circles) is, for the most part, the dominant contribution to the total execution time. For the case of the model of M31, there are three distinct ranges of execution times for calculating gravity; the fast steps with execution times in the range 4  ×  10- 3 s - 2  ×  10- 2 s, steps with intermediate execution times in the range 0.15 s - 0.4 s, and the slow steps with execution times of [formula] s). We group the steps in these ranges and label them as "FSeq" (fast sequence), "ISeq" (intermediate sequence), and "SSeq" (slow sequence), respectively. The decrease in the number of steps with execution times above 1 s (FSeq) to ten times during the first 101 steps is a consequence of the block time step reducing the number of calculations for slowly moving i-particles. This is the main reason for the acceleration by the block time step. The achieved mean elapsed time per step is 0.33 s, and is a little above 10% of the execution time to calculate gravity in the SSeq. The nearly fixed cost to calculate the position and mass of pseudo j-particles (black crosses), which is 3.2  ×  10- 2 s, sometimes becomes the most time-consuming function at a given time step. This suggests that further optimization of that function might also accelerate the code. Performing a more precise time integration is also possible without worsening the total elapsed time. For example, one could increase the number of i-particles at the cost of an increase in the execution time to calculate gravity. Unless the increase of the execution time in the FSeq is much greater than that the execution time to update j-particles, this would not increase the total elapsed time since the total elapsed time is still dominated by the execution of the SSeq in the gravity calculation is the main reason for the acceleration using the block time step. The costs for correcting the velocity of i-particles (black triangles) roughly fall into three sequences as well, with execution times of 5  ×  10- 5 s, 2.6  ×  10- 3 s, and 5  ×  10- 3 s. This implies that the number of i-particles within each sequence is fairly constant and suggests the scheme is successfully reducing the calculations of gravity for i-particles in the low density regions. The required time to predict position and velocity of j-particles (green crosses) is almost constant at 4.6  ×  10- 3 s, roughly the same as the slowest sequence for the corrector, in every time step. This is because the number of j-particles is always equal to [formula].

The mean interval between successive tree reconstructions is about 12 steps. The costs of functions related to tree reconstruction (generation and sorting Peano-Hilbert keys, sorting N-body particles using Peano-Hilbert key, tree construction, and split i-particle groups in the low dense region) are almost independent of the particular time step. Because the radix sorting of 32-bit integers with 64-bit keys, which takes about 0.1 s, is the limiting process, further acceleration of the sorting library is essential to reduce the cost to reconstruct tree structures. The execution of the SSeq of the tree traversal and tree reconstruction often form a pair. Because tree construction is an order of magnitude faster than tree traversal, even a tiny increase in the cost to traverse the tree structure is greater than the cost of the tree reconstruction, and thus, the execution of the SSeq of tree traversal becomes a trigger to rebuild the tree structure.

Dependence on Number of N-body Particles

To examine the effects of ij-parallelization, we measured elapsed time while varying the number of i-particles, Ni, and keeping the total number of N-body particles fixed at [formula] 8,388,608. Figure [\ref=fig:Ni@M31] presents the results for varying number of threads that share a common i-particle, S, on M2090, K20X, and GTX TITAN X. The elapsed time monotonically decreases with Ni. This feature is associated with the reason for the acceleration by the block time step, and roughly scales as N1i if [formula] except for [formula]. The steep increase at [formula] for all cases except for S  =  32 is related to gravity calculations for i-particles in the lowest density regions. As noted in §[\ref=sec:implementation:splitGroups], GOTHIC tends to increase the number of interactions in the low density regions and this causes an increase in the elapsed time. Because [formula] particles share the tree traversal, the steepness of the increase becomes weaker with greater S and vanishes for S  =  32. Also, particles in the lowest density regions have the longest free-fall time and would have the longest time step; therefore, they would not be selected as i-particles if [formula], and this makes the increase of elapsed time steeper. If further optimizations or another algorithm succeeded in reducing the steep increase of the elapsed time at [formula], then the total elapsed time GOTHIC could be significantly decreased.

The critical number 104  /  S, which separates the monotonic decrease with Ni and the constant elapsed time irrespective of Ni, is determined by the number of running CUDA cores. Because the number of thread-blocks per SM is two, the number of threads per block is 256 or 512, and the number of SMs per device is around 20. The number of threads to saturate CUDA cores is given by the product of these three factors and is around 104. Introducing ij-parallelization activates S times more threads compared to simple i-parallelization. These two properties result in the critical number being 104  /  S. The origin and value of the critical number are same for the case of direct summation [\citep=Miki2012].

The dependence of GOTHIC on the number of N-body particles is the final concern we address. Figure [\ref=Ntot@breakdown] presents the elapsed time as a function of the total number of N-body particles with [formula] on M2090, K20X, and GTX TITAN X. Contributions of each function are measured as the elapsed time averaged by 1,024 steps. The number of N-body particles is changed from 210  =   1,024 to 224  =   16,777,216. The two-fold greater global memory on GTX TITAN X compared with others enables it to perform N-body simulation with 224 particles that could not run on M2090 or K20X. Traversing the tree structure (red circles with dashed line) always dominates the execution time and scales roughly as [formula] if [formula] on all GPUs. It is slightly weaker than the expected scaling of the tree algorithm as O(Ni log Nj). The scaling gradually becomes worse when decreasing the problem size. In [formula], the execution time to calculate the mass, the position, and the size of pseudo j-particles (blue squares with dotted line) approaches a constant floor on each device. Furthermore, the floor value is not negligible compared with the elapsed time to calculate gravity and increases its contribution. Improving the scaling is also necessary to achieve a shorter time-to-solution for [formula].

Contributions from tree construction (magenta diamonds with dot-dashed line) and orbit integration (green triangles with triple-dot-dashed line) are comparable for most values of [formula] and negligibly small in any case. It should be noted that performance optimization of tree construction is also helpful to decrease the time-to-solution even though its execution time itself is negligible. As stated in §[\ref=sec:implementation:rebuildInterval], the interval between successive tree constructions is determined by the balance between execution time of tree traversal and construction. Therefore, performance enhancements of the function to update the tree structure can accelerate N-body simulation by decreasing the execution time for calculating gravity. This is a characteristic behavior of GOTHIC due to optimizations affecting multiple functions.

The measured elapsed time per step is 0.47 s (0.58 s), 0.39 s (0.38 s), and 0.14 s (0.21 s) for the M31 model (the NFW sphere) with 223  =   8,388,608 particles on M2090, K20X, and GTX TITAN X, respectively. On GTX TITAN X, we ran N-body simulation using 224  =   16,777,216 particles and they took 0.30 s and 0.44 s per step for the M31 model and the NFW sphere, respectively. [\citet=Ogiya2013] reported that the elapsed time per step of their code was ~  5 s on M2090 for the NFW sphere with 224 particles. This indicates that the sophisticated algorithms and optimizations adopted in GOTHIC, and performance improvements of GPU achieve more than ten times acceleration of N-body simulations compared to [\citet=Ogiya2013].

Discussion

The tree method has a better scaling compared to the direct method and is always faster in the high N-regime. However, in the low N-regime, the direct method becomes faster owing to its simplicity. Here, we briefly discuss the transition point at which to switch between the tree method and the direct method. [\citet=Miki2013] reported that the execution times for calculating gravity by the direct method with N  =  212  =   4,096 and N  =  213  =   8,192 on M2090 are 9.7  ×  10- 4 s and 1.9  ×  10- 3 s, respectively. They are nearly the same as those with GOTHIC (see Fig. [\ref=Ntot@breakdown]). Since 104 is a sufficiently large number of N-body particles to obtain the sustained performance on M2090, the growth of the elapsed time is proportional to N2 for [formula]. This implies that the tree method becomes faster than the direct method on GPU for [formula]. Since direct N-body codes on GPU can maintain their O(N2) scaling down to ~  103 through ij-parallelization [\citep=Miki2012], direct N-body codes becomes faster than the tree method in [formula]. Furthermore, [\citet=Miki2013] adopted the shared time step instead of the block time step, so further speed up of their direct N-body code is possible. In summary, the execution time of GOTHIC is comparable with that of direct N-body codes if N  ~  104 and becomes shorter the larger the problem size.

To estimate the achieved performance of GOTHIC, we have first counted the number of interactions computed in each time step. The counting of interaction pairs is done in a separate run to that of measurements of the elapsed time in order to remove the additional burden of the performance measurements. Figure [\ref=fig:performance] shows the measured results as a function of the time step. The directly measured values are the calculated number of interactions in each time step and are shown in Figs. [\ref=fig:performance]a and [\ref=fig:performance]b. They have similar values on different generations of GPUs. The origin of the differences is differences of the configuration of the kernel function to calculate gravitational force (see Tab. [\ref=tab:results:configuration:kernel]). The gradual increase in the number of interactions with time step in the FSeq is the reason for the growth of the execution time for calculating gravity while using the same tree structure repeatedly. Since rebuilding the tree structure is auto-tuned as described in §[\ref=sec:implementation:rebuildInterval], the time steps at which the tree is rebuilt will differ depending on the problem or the utilized GPU. The number of interactions calculated per second (Figs. [\ref=fig:performance]c and [\ref=fig:performance]d) on each GPU is derived by combining independent measurements of the elapsed time. The measured results exhibit clear differences among the three GPUs, reflecting their theoretical peak performance.

The significant difference in each time step is attributable to the block time step. Step by step comparison between the number of interactions and the execution time in each time step reveals two things: (1) the lowest calculation speed is associated with the highest number of interaction pairs (as highlighted by vertical bands in Fig. [\ref=fig:performance]) and (2) the minimum number of interaction pairs does not necessarily result in the highest calculation speed (this is more evident in the M31 model). The SSeq which corresponds to the maximum number of interaction pairs per step includes all i-particles in the lowest density regions, while the ISeq and FSeq, which correspond to the smaller number of interaction pairs per step, do not include i-particles in the lowest density regions. Including i-particles in the lowest density regions drastically increases the number of distance evaluations between a group of i-particles and pseudo j-particles. The remedy for this, introduced in §[\ref=sec:implementation:splitGroups], starts to work at later time steps, and the calculation speed decreases significantly. This is also the case with the steep increase of the elapsed time around [formula] observed in Fig. [\ref=fig:Ni@M31]. The lowest number of interaction pairs does not lead to a sustained performance in the M31 model either. We find that the highest calculation rate is associated with an intermediate number of interaction pairs.

Conversion from the measured elapsed time to achieved performance requires an assumption about floating-point operation counts per interaction; however, such a conversion is not always rigorous especially in realistic scientific computations. Various values of the floating-point operation counts have been adopted in the literature for collisionless N-body simulations. Examples in studies using GPU(s) are: 20 by [\citet=Nyland2007], 26 by [\citet=Miki2012] [\citet=Miki2013], and 23 by [\citet=Bedorf2014], while 38 appears to be the typical value used in astrophysics [\citep=Kawai1999] [\citep=HamadaIitaka2007] [\citep=NitadoriMakino2008] [\citep=Hamada2009] [\citep=HamadaNitadori2010] [\citep=Tanikawa2013]. The reason for the differences lies in the estimation of the execution cost of the inverse square root. In this study, we assume that the cost of executing the inverse square root corresponds to the ratio of the throughput of the reciprocal square root to that of addition or multiplication. This is found to be 8, 6, and 4 Flops (floating-point operations) on M2090, K20X, and GTX TITAN X, respectively. It should be noted that an alternative is adopting 4, 3, and 2 Flops on different generations of GPUs [\citep=Capuzzo-DolcettaSpera2013] [\citep=Bedorf2014]. This choice takes into account the fact that GPUs by NVIDIA support FMA operations and thus can execute 2 Flops per clock cycle. The remaining operations are three subtractions, three multiplications, and seven FMA operations (20 Flops in total), because GOTHIC calculates not only the gravitational force but also the gravitational potential (an FMA operation returns the potential). In summary, we assume that floating-point operation counts per interaction are 28, 26, and 24 Flops, respectively, on M2090, K20X, and GTX TITAN X.

Table [\ref=tab:discussion:performance] summarizes the measured number of interactions calculated per second and the corresponding performance in units of GFlop/s (Giga Floating-point operations per second) for the NFW sphere and the M31 model with N  =  223  =   8,388,608 on the three generations of GPUs. The averaged performance over time steps on M2090, K20X, and GTX TITAN X are around 320 GFlop/s, 360 GFlop/s, and 1750 GFlop/s, respectively. They correspond to 10-30% of the theoretical peak performance. The maximum performance on each GPU is around 40%, 20% and 55% of its theoretical peak performance on M2090, K20X, and GTX TITAN X, respectively. Finally, the minimum performance over several time steps drops to less than 10% of the theoretical peak performance except for the M31 model on M2090. This is the case with the highest number of interaction pairs as shown in Fig. [\ref=fig:performance]; i.e., it is equivalent to the performance of the shared time step. This means that the benefit of adopting the block time step lies not only in avoiding unnecessary calculations to follow the time evolution of the system but also in increasing the average calculation speed per time step.

[\citet=WatanabeNakasato2014] proposed a hybrid tree algorithm to reduce the calculation cost of collisionless N-body simulations applying Particle-Particle Particle-Tree (PPPT) algorithm originally developed by [\citet=Oshino2011] for collisional systems. They divided the gravitational force calculation into two steps, short-range and long-range, and reduce the relative frequency of long-range force calculation. Because neglecting small changes of the gravitational field in the distant region does not generate a significant error in the force calculations, they succeeded in accelerating the computations without loss of accuracy. They reported a 20% acceleration of the N-body simulation for a Plummer sphere; however, the speed up rate probably depends on the distribution of N-body particles. In this study, the acceleration by the block time step compared to the shared time step in a Plummer sphere is around 50% for a given typical accuracy while that in the M31 model reaches 500%. This suggests that the hybrid tree algorithm has the potential to accelerate the calculation more than what was reported by [\citet=WatanabeNakasato2014]. Also, combining the hybrid tree algorithm with GOTHIC is possible because the original PPPT algorithm was designed to couple with the individual time step scheme.

There is another unexplored avenue to further accelerate GOTHIC. The block time step introduces an order of magnitude variance of the number of i-particles Ni in each time step. As clearly shown in Fig. [\ref=fig:Ni@M31], the optimal value for the number of threads to share an i-particle, S, depends on Ni. In the current version of GOTHIC, we fix S throughout in the simulation to implement the code easily. However, dynamically adjusting the optimal value for S in each time step would accelerate the code especially in the low Ni-regime. This sort of auto-tuning is suitable to optimize codes whose performance depend strongly on the inputted problems, and might become a key issue to achieve a good strong scaling in future studies.

Operations for floating point numbers using half precision are supported on current GPUs and are twice as fast as those using single precision on the Pascal generation of GPUs designed for HPC (i.e., GP100 architecture). The number of mantissa bits for half precision is 10 in the IEEE 754-2008 standard. [\citet=Tanikawa2013] showed that the approximate inverse square root function with 12 bits accuracy could provide sufficient accuracy for collisionless systems and implemented this in their software library "Phantom-GRAPE", a high-performance direct N-body library for CPU. This suggests that the approximate inverse square root function using half precision might also give sufficient accuracy for collisionless N-body simulations. Because the inverse square root is the heaviest function in N-body simulations, it would accelerate N-body simulations further. Even if the accuracy is not sufficient, the Newton-Raphson method can improve the accuracy at only a small cost. Furthermore, adopting arithmetic operations using half precision is promising in the tree method since the distance evaluation stage described in §[\ref=sec:implementation:walkTree] does not require a precise value of the distance in single precision. Current NVIDIA GPUs support the approximate inverse square root function rsqrtf() with at least 21 bits accuracy [\citep=CUDA7.5Manual] for variables at single precision and they were found to successfully accelerate collisionless N-body simulations [\citep=Nyland2007] [\citep=Miki2012] [\citep=Miki2013]. Exploiting the half precision version of rsqrtf(), if it exists, would also increase the performance of realistic scientific computations.

Summary

Adopting the tree method is a common way to accelerate collisionless N-body simulations in astrophysics, even on GPU. Many earlier studies presented tree codes efficiently running on GPU(s), yet none had coupled their code with the block time step [\citep=Nakasato2012] [\citep=Ogiya2013] [\citep=Bedorf2012] [\citep=Bedorf2014] [\citep=WatanabeNakasato2014]. Since the block time step can also accelerate N-body simulations significantly, we have developed a gravitational octree code (GOTHIC), which is accelerated by the block time step. The code adopts the breadth-first search, and runs entirely on GPU, just like Bonsai by [\citet=Bedorf2012] [\citet=Bedorf2014]. The algorithm in the tree traversal is an improved version of the algorithm proposed by [\citet=Ogiya2013], which used a depth-first search. GOTHIC also does adaptive optimizations, i.e., auto-tuning, by monitoring the execution time of each function. The optimizations reduce the time-to-solution by balancing the execution time of multiple functions, and using optional ij-parallelization to maintain high performance in the low Ni-regime.

The performance of the code is measured on NVIDIA Tesla M2090, K20X, and GeForce GTX TITAN X, which are representative GPUs of the Fermi, Kepler, and Maxwell generation of GPUs, using realistic particle distributions found in astrophysics. The results show that the code with the fiducial configuration (the block time step with the acceleration MAC) achieves around a 3-5 times acceleration compared to the shared time step, and is faster than the public code Bonsai. The elapsed time of the code scales roughly as N for [formula]; the dependence is slightly weaker than the expected scaling for the tree method, O(N log N). The averaged performance of the code corresponds to 10-30% of the theoretical peak performance of each GPU. The measured elapsed time per step of GOTHIC is 0.30 s and 0.44 s on GTX TITAN X when the particle distribution represents the Andromeda galaxy and the NFW sphere, respectively, with 224  =   16,777,216 particles. The achieved time-to-solution is more than ten times smaller than that achieved in [\citet=Ogiya2013]. There are still some possibilities for further optimizations that can be explored, for example: (1) adopting a more sophisticated algorithm such as the hybrid tree algorithm proposed by [\citet=WatanabeNakasato2014], (2) performing deeper optimizations focusing on specific generation of GPUs, (3) auto-tuning of the optimal number of threads S in ij-parallelization, and (4) utilizing new functions provided by hardware vendors or compilers such as operations in the half precision.

Acknowledgements

YM is particularly grateful to Go Ogiya for fruitful discussions and providing detailed information about his code implementation and performance measurements. YM also appreciates suggestions from Kohji Yoshikawa on code optimizations. YM has benefited from feedback by Takanobu Kirihara on using a beta version of GOTHIC which improved the performance in realistic simulations. We thank Daisuke Takahashi for providing information on auto-tuning. We would like to express our gratitude to Alexander Y. Wagner for careful reading of the manuscript and comments that improve the paper. Numerical simulations were performed on HA-PACS at the Center for Computational Sciences, University of Tsukuba. The present study was supported by the Japan Science and Technology Agency's (JST) CREST program entitled "Research and Development of Unified Environment on Accelerated Computing and Interconnection for Post-Petascale Era." This research was also supported in part by the Grant-in-Aid for Scientific Research (B) by JSPS (15H03638).

Space-filling Curves

Listings [\ref=source.code:encPeano] and [\ref=source.code:decPeano] are implementations of the Peano-Hilbert key encoder and decoder, respectively, written in C. The algorithm is an extension to 3D space of the implementation in 2D space by [\citet=LamShapiro1994]. The generation of Peano-Hilbert keys boils down to the rotation and/or inversion of the fundamental block. Since the rotation and inversion in the 3D space are non-commutative operations, level-by-level encoding/decoding is necessary. The number of logical operations is minimized using the Karnaugh map. The data type PHint is unsigned int or unsigned long int depending on whether the bit length of the key is less than or equal to 30 (the maximum size that fits in a 32-bit integer), respectively.

For comparison, Listing [\ref=source.code:genMorton] shows how the Morton key generator works up to 63 bit keys. [\citet=Bedorf2012] provided Morton key generator in 30 bits based on [\citet=RamanWise2008]. Listing [\ref=source.code:genMorton] is simply an extension of this to 63 bits. It is much simpler than the Peano-Hilbert key generator; however, it does not have a one-stroke sketch nature.

Comparison of Enclosing Balls

We have implemented 5 kinds of enclosing ball generators: (1) the smallest enclosing ball (SEB) given by the algorithm proposed by [\citet=Fischer2003], (2) the efficient bounding sphere (EBS) proposed by [\citet=Ritter1990], (3) the sphere centered on the geometric center of the enclosing rectangular cuboid (GEO), (4) the sphere centered on the center-of-mass of particles (COM), and (5) the smaller of the spheres generated by GEO and COM (CMP). The smaller radius of the enclosing ball mitigates the increase of the number of interactions especially in the low density regions and reduce the elapsed time. From this point of view, the best choice is the SEB, which has the minimum radius. On the other hand, the precise determination of the SEB is a time-consuming process. Therefore, the optimal choice for the generator should be determined by comparing the elapsed times of the code with the various generators. In this section, we summarize the performance of the enclosing ball generators.

First, we compared the radii of each enclosing ball, [formula]. Figure [\ref=fig:enclosing.ball] shows amount of radius over-estimation, [formula], as a function of the radius of the smallest enclosing ball, [formula]. After SEB, the EBS method results in the smallest radii; its over-estimation is 5% in most cases and ~   10% in the worst case as originally claimed by [\citet=Ritter1990]. The GEO gives somewhat little bigger radii; however, it is smaller than [formula] in most cases. On the other hand, [formula] in the COM is much bigger, and it exceeds [formula] in the low density regions (i.e., the region with large [formula]); hence, the number of operations executed in the gravity calculations become much greater than other enclosing ball models. The CMP resembles the GEO because the COM predicts larger radii than the GEO in most cases.

Table [\ref=tab:enclosing.ball] lists the costs to generate each enclosing ball on different GPUs. The cost is measured by calling the clock64() function within the __global__ function in the CUDA code and translated into the elapsed time by dividing by the number of concurrent warps and the clock cycle frequency. The elapsed time to generate enclosing balls is always negligibly small compared to that to calculate gravity. The dependence of the elapsed time on the particle distribution is much weaker compared to that of the gravity calculation.

Modeling the Interval of Tree Rebuild

In the power-law growth model, the required time to calculate gravity at the i-th step is assumed to grow as

[formula]

where t1 and r are the scale factor and the common ratio, respectively. The total elapsed time after n steps is given by

[formula]

The first and the second derivatives of [formula] with respect to n are calculated as

[formula]

Therefore, the desired condition for rebuilding the tree becomes

[formula]

if the right hand side of ([\ref=eq:appendix:rebuild.interval.modeling:2nd.derivative.in.power.law.model]) is positive. Substituting ([\ref=eq:appendix:rebuild.interval.modeling:guess.in.power.law.model]) into ([\ref=eq:appendix:rebuild.interval.modeling:2nd.derivative.in.power.law.model]) yields the equation

[formula]

which implies that r  >  1 is the necessary condition to minimize [formula].

In the parabolic growth model, we assume

[formula]

where t1, a, and b are fitting parameters determined by the least squared method. The total elapsed time after n steps is written as

[formula]

The first and the second derivatives of [formula] with respect to n are calculated as

[formula]

Equating ([\ref=eq:appendix:rebuild.interval.modeling:1st.derivative.in.parabolic.model]) to zero yields the optimal choice as

[formula]

Putting ([\ref=eq:appendix:rebuild.interval.modeling:guess.in.parabolic.model]) into ([\ref=eq:appendix:rebuild.interval.modeling:2nd.derivative.in.parabolic.model]) gives the expression of the second derivative at the extremum:

[formula]

Therefore,

[formula]

is the necessary condition to get the shortest time-to-solution.