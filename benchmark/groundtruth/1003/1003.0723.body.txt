Securing Interactive Sessions Using Mobile Device through Visual Channel and Visual Inspection

Introduction

Securing connection to a server through an untrusted network terminal is challenging even if the user has additional factor for authentication like one-time-password token, smartcard, or a mobile phone. One of the hurdles is the difficulty in securely passing information from the terminal to the device, and presenting the jointly verified authentic information to the user in a user friendly manner. Using traditional channel to connect the device and the terminal, like wireless connection or plug-and-play connection, are subjected to various man-in-the-middle attacks. Even if a secure channel can be established, it is still not clear how the additional device can help in authenticating subsequent messages rendered on the untrusted terminal's display.

A number of recent works utilize cameras in the mobile devices to provide an alternative realtime communication channel from a display unit to a mobile device: messages are rendered on the display unit in a form of, say 2D barcodes, which are then captured and decoded by the mobile device via its camera. Although such visual channel could be eavesdropped by "over-the-shoulder" attacks, it is arguably impossible to modify or insert messages, and thus secure against man-in-the-middle attack. Visual channel has been exploited in a few works in verifying the session key exchanged over an unsecured channel, for instance seeing-is-believing proposed by McCune et al. [\cite=mccune2009seeing]. There are also proposals on verifying untrusted display, for example, Clarke et al. propose verifying the display screen using stabilized camera device [\cite=clarke2002untrusted]. In this paper, we take a step further by investigating authentication of interactive sessions, with consideration that many cameras are unable to cover the whole screen in a single view with sufficient precision. An example of interactive session is online banking application where a user can browse and selectively view pervious transactions, and carry out new transactions. A typical screenshot would contain important information like the user's account information, and less sensitive information like advertisements, help information, and navigation information, as shown in Figure [\ref=fig:OurScheme:origianltable].

During an interaction session, after a session key ks has been securely established between the server and the mobile device (could be established using seeing-is-believing [\cite=mccune2009seeing]), there could be many subsequent communication messages that require protection by ks. These messages may need to be rendered over different pages, or in a scrolling webpage where not all of them are visible at the same time. We remark that it is not clear how to protect them. For instance, one may render the messages as 2D barcodes, each protected by the same ks. To view the message in a 2D barcode, the user moves the mobile device over the barcode, and the device will capture, authenticate and display the message on its display panel. However, as there are many barcodes associated with the same key, it is possible for a dishonest terminal to perform "rearrangement" attack: replays barcodes or shows barcodes in the wrong order.

The above attack arises due to the limitation that the camera is unable to capture the whole screen with sufficient precision, and not all messages can be rendered together in a single screenshot. We treat the problem as the authentication of messages rendered in a sequence of large 2D regions, where only region in a small rectangular window can be captured at one time. There are a few straightforward methods to overcome the rearrangement attack. For instance, one may prevent the attack by requiring the user to scan all the barcodes with his mobile device, and all the messages will be authenticated and rendered by the mobile device. However, it is troublesome for the user to scan all the barcodes, and there are situations where the user only wants to view some, but not all, of the messages. In addition, it is less preferred to navigate and browse the messages (e.g. a large table of transactions) within the relatively small display panel. In Section [\ref=sec:alternative], we will discuss a few other straightforward methods and their limitations.

Our solution is to use a barcode scheme that given a message m and a visual cue v, is able to produce a barcode image that not only carries m as its payload, but also visually appears as v (see examples in Figure [\ref=fig:OurScheme:MS1] and Figure [\ref=fig:OurScheme:MS23]). Our paper realizes such barcode scheme using technique borrowed from fragile image watermarking [\cite=cox1997secure]. To embed a long messages into several barcodes, our main idea is to have a visual cue on each barcode indicating its position. By visually inspecting the visual cues, the user can readily verify that the barcodes are in the correct arrangement. For example, in Figure [\ref=fig:OurScheme:MS1], the visual cues are numeric numbers increasing by 1 from left to right, top to bottom. The black dot beside the number "2" indicates that the barcode is at the end of row, and the black block beside the number "10" indicates that it is the last (i.e. bottom-right) barcode. With the arrangement of barcodes verified, the user can then browse selective barcodes independently with his mobile device.

In our security analysis, we consider the four parties setting where a user, who has a mobile device, wants to interact with a server via a network terminal. We focus on three security models. In the first model, the Internet terminal, including its CPU, keyboard and display unit, is untrusted by the user, whereas the mobile device is trusted. This model is motivated by the challenging problem in securing Kiosks [\cite=garriss2006towards] [\cite=kauer2007oslo], where Kiosks are untrusted public network terminal like workstations in Internet café.

In the second model, motivated by two-factor authentication, we consider scenarios where at least one of the terminal or mobile device is honest. We found that under the first model, it is possible to provide both confidentiality and authenticity; whereas under the second model, although authenticity can be achieved, it is not clear how to achieve confidentiality.

In the third model, we take one more step beyond two-factor authentication and consider a tricky setting where both the terminal and mobile device could be dishonest, but they do not collude in the sense that they do not know how to communicate with each other. This model is motivated by scenarios where the terminal and mobile device are compromised, but independently by two different adversaries, for instance, a dishonest mobile device that always says "authentic" for whatever authentication it is supposed to carry out, and a network terminal that is tasked to deceive the user to accept a message given to the terminal. To detect such dishonest mobile device, our proposed method requires the mobile device to extract and produce a human readable proof from the authentication tag. A corresponding proof is also shown in the terminal's display and hence the user can visually verify whether they are consistent, as shown in Figure [\ref=fig:OurScheme:MS23].

In addition to security requirements, user experience is also important. Requiring the user to take snapshot of the screen is rather disruptive from the user's point of view. We employ augmented reality to provide better user experience in verification. The design of our 2D barcode and the subregion authentication takes useability into consideration and fits nicely in the framework of augmented reality. One example is as shown in Figure [\ref=fig:OurScheme:MS1]. The screenshot displayed by the terminal is a combination of sensitive data and non-sensitive data like advertisement and menu. The sensitive data are replaced by 2D barcodes with visual cue as described before. The user treats the mobile device as an inspection device and places the mobile phone over the region to be inspected. In realtime, the mobile device captures and verifies the 2D barcode. If it is authentic, the decrypted message is displayed. The non-sensitive portion of the screenshot is also displayed as it is to help the user to navigate. We give a proof-of-concept system where we use a laptop equipped with a webcam to simulate the mobile device to show the feasibility of our methods.

Models and Formulation

There are four parties involved in our problem: the user, the server, the mobile device and the network terminal. Let us call them User, Server, Mobile, and Terminal respectively. In our framework, the term "user" literately refers to a person, and the mobile device is equipped with a camera, input device, a small display unit and a chip that can perform decoding of barcodes.

The communication channels among the four parties are as shown in Figure [\ref=fig:message_passing]. Note that there is no direct communication link between Mobile and Server. With 3G mobile network and WiFi connection widely available, one may argue that the model should consider such a link. Nevertheless, there are situations where the connection is not available due to cost or other constrains. In addition, there are also security concerns if the mobile device has Internet connection during the transactions: if Mobile can directly send messages to Terminal, they may collude and conduct coordinated attack. Table [\ref=table:tableofnotation] gives a summary of our notations.

We consider the following security models for the channel between Server and User:

Model 1: Terminal is not trusted by User, but Mobile is trusted and we want to protect both confidentiality and authenticity.

Model 2: At least one of Terminal and Mobile is honest and we want to protect authenticity.

Model 3: Both Terminal and Mobile could be dishonest but they do not collude and we want to protect authenticity.

In Model 3, we treat the dishonest Terminal and Mobile as two different adversaries [formula] and [formula] with two different goals. [formula] is the dishonest terminal and its intension is to trick the user to believe that a given message m' is authentic. The actual value of m' is not determined prior to the connection. We can view it as a randomly chosen message that is passed to the [formula]. The adversary [formula] is the dishonest mobile and has a easier goal: it is free to construct any message and trick the user to wrongly believe that it is authentic. An example of [formula] is one who always accepts whatever verification it is tasked to do. To capture the notion that they do not collude, we impose the restriction that [formula] and [formula] do not know how to communicate with each other, and the forge message m' is randomly chosen and hold by one party. Hence, we exclude the attack where [formula] covertly sends the message m' to [formula] through the visual channel.

Protocols

We now give our proposed protocols for securing the communication between Server and User assuming we have a barcode embedding technique that can protect the integrity and confidentiality of its payload, and visible visual cue can be rendered onto the barcode to indicate the barcode location as in Figure [\ref=fig:OurScheme:MS1]. Given a message m, a visual cue v, and a session key ks, let us write the barcode (represented as images) as [formula]. For clarity in presentation, we first consider the case where the message can be embedded into one barcode block whose size is small enough to be entirely captured by Mobile's camera with sufficient precision. Thus, we take the visual cue as a single dot, indicating to the user that there is only a single barcode to be read. We will later study the case for multiple messages in Section [\ref=sec:visualchannel] and Section [\ref=sec:subregionauthentication].

We assume that Server has already established a long term shared key with Mobile when the user registers an account with the server. In additional, for model 2 and 3, we assume that User has established a password with Server. Before each interactive session, Server authenticates User and Mobile to get a session key ks. A secure key exchange can be derived from modified seeing-and-believing [\cite=mccune2009seeing] and combination of the proposed method in this section. Due to space constrain, we do not include details in this paper.

Server to User

Consider the case where Server wants to send a message [formula] to User. We propose two methods, denoted MS1 and MS2 (message from server), where method MS1 is more user-friendly compared to MS2, but it requires that Mobile is trusted.

[formula]: [formula];

[formula]: v;

User verifies v;

[formula]: [formula];

[formula]: [formula];

[formula] accepts [formula].

User to Server

Now we consider the following methods MU1 and MU2 (message from user) for sending the message [formula] to Server. Method MU1 protects both confidentiality and authenticity of the message, whereas method MU2 protects only the authenticity but involves less user operation.

Although involves more steps, MU2 is less tedious from the User's point of view, since User does not need to enter [formula] using Mobile's input device. The corresponding steps for MU2 are summarized below:

Analysis

In this section, we analyze our methods under different adversary models.

For both methods, Terminal plays the role of a relay point for passing message and thus a malicious Terminal is the man-in-the-middle. Hence, this is the classical setting where the two end points ( Server and Mobile) having a shared key want to communicate over a public channel. The cryptographic technique (encryption and message authentication code) can secure the channel and provide both confidentiality and authenticity.

It is clear that MU2 and MS2 cannot protect the confidentiality under this model as the messages are sent in clear through Terminal, and thus they are not suitable in this model.

Suppose Terminal is dishonest. In both directions of the communication, we can treat the barcode as the MAC of the message, [formula] and [formula] respectively, and Terminal does not have the key. Similar to analysis for Model 1, this is a classical setting and the authenticity of the message inherit from the MAC we used in the barcode construction.

On the other hand, let us consider the case where the Mobile is dishonest. In MU2, Terminal is honest and will forward [formula] to Server as it is, thus, it is impossible for Mobile to modify [formula] without Server notices. Similarly, in MS 2, since the actual message [formula] is displayed by the honest Terminal, User can compare the displayed message and thus any modification can be detected.

Note that MU1 and MS1 is not secure in this model: if Mobile is dishonest and change the message to m', there is no way for User or Server to verify it.

Let us first analyze MU2. Recall that the goal of a dishonest Terminal is to trick Server to accept a message [formula]. To do so Terminal must send Server the message [formula], and obtain a barcode b contains [formula] and c. Server accepts [formula] only if the verification code c is presented. Since c is randomly chosen, Terminal is unlikely to succeed in guessing c. Therefore, he needs to get c from user. Without any hint from Terminal, Mobile is not able to display the message that the user is expecting.

Now let us analyze MS 2. In this case the dishonest Terminal wants to trick User into accepting a message [formula]. To achieve the goal, it must display [formula] side-by-side with the barcode. As Terminal does not know the key ks he is unable to forge the barcode. Now, consider the dishonest Mobile. Recall that there is no communication from the Terminal to Mobile, the Mobile is unable to display the message [formula] which is required to trick User to accept [formula].

Table [\ref=table:summaryofmethod] summarizes the security and user friendliness of our methods under different models.

Visual Channel

A main component in building our visual channel is the construction of 2D barcode with visual cues: given a secret key [formula], a message m, and a visual cue symbol v we want to produce a 2D barcode [formula] such that the cue v is clearly visible, and the message m can be extracted under noise. On the other hand, there are security requirements on the confidentiality of m and integrity of m and v. Any modification on m and v must be detected.

Construction Overview

There are a number of stages of the visual channel construction:

Thus, our barcode is a black and white image with red pixels.

Encoding with Visual Cue

When a message is too large, multiple barcodes are required to encode it. As mentioned in the introduction, multiple barcodes protected by a single session key are subjected to "rearrangement" attack. To detect the attack, we propose binding location information to the barcode using visual cue. This section gives a method in embedding the visual cue. Note that the process of embedding a visual cue to a barcode is essentially digital watermarking, where the visual cue is the host, and the barcode is a message to be "watermarked" to the host.

Given a n-bits message m1, let us arrange it as a x by y binary matrix where n = x  ·  y and x is even. Let us assume that the given visual cue is a x / 2 by y pixels image where each pixel is either 0 (representing a black pixel) or 1 (representing a white pixel). Therefore, every 2 bits in m is associated with 1 pixel of the visual cue, and together they can be represented with 3 black-and-white pixels in the final barcode. The 3 pixels are arranged in a "L"-shape as shown in Figure [\ref=fig:lgroup]. Let us call the 3 pixels as a L-block. The 23 combination of values in a L-block is divided into two groups: W and B. The L-blocks in W have more white pixels and thus the L-blocks appear as "white". Conversely, the L-blocks in B will appear as "black".

Given a binary value v1∈{0,1} of a pixel of the visual cue image, we want to encode two bits 〈b1,b2〉 into a three pixels L-block, such that the brightness of the L-block can be adjusted according to v1. For instance, if v1  =  1, the encoding outputs only elements in W. Since there are 4 elements in W, it is possible to encode the two bits b1 and b2. Beside for the value of v1, there is no further constraint on how the encoding of 〈b1,b2〉 to the 4 elements in W is to be done. In order to prevent the adversary from modifying the appearance of the visual cue, the mapping from the 2 bits 〈b1,b2〉 to the three pixels of the associated L-block, 〈p1,p2,p3〉, has to be kept secret. Hence, the key space for encoding a bit pair is 4!  ×  4!  =  576.

To decode a barcode, Mobile applies the decoding and decryption functions in a reverse order and ignore the bit v1. That is, it first extracts the bit pairs from every L-blocks, and get the message m'. Next, error correcting is applied and the authenticity of the message can be verified.

Security Analysis

We would like our barcode scheme to achieve the following properties: (1)authenticity and confidentiality of [formula] and (2) the integrity of visual cue.

However, the above analysis does not hold when we consider the whole process of decoding, where the error correction is included. Recall that, due to inevitable noise, we need to apply error correcting before extracting [formula]. Therefore, when small number of L-shape blocks are corrupted, the payload m1 can still be correctly decoded. Hence, the choice of error-correction and the design of the cues cannot be done separately. Furthermore, some error-correction code can correct more errors than its guaranteed level in some situations. Due to the concern of forgery, it is important not to correct those errors.

To prevent an adversary from making small changes that can deceive the user and yet get verified, one design consideration of the visual cue is to choose symbols with large mutual Hamming distance from each other. In our implementation to be described in Section [\ref=sec:implementation], we use numerical digits as visual cue, where the minimum hamming distance for two symbols is 14 "L-blocks" (for example, the number "1" and "7", "0" and "8"). We choose parameters of error correcting code that is able to tolerate 4 bits noise for every 63 bits. Note that modifying a "L-blocks" may result in two bits flipped, thus, the probability that an attacker can modify the visual cue of a barcode to another is less than [formula] where [formula] is the cumulative distribution function of the binomial distribution [formula].

Visual Cues for Verification of Multiple Barcodes

In this section, we discuss a few designs of visual cue, in particular, for barcodes appeared in a linear sequence, and barcodes rendered as table. Recall that the main purpose of the visual cue is to bind location information to the barcodes, so that User can visually verified that the barcodes are in the correct arrangement.

The numerical value of the visual cue symbol on the top row, leftmost block is 1. The value increments by 1 from left to right. At the end of the row, the increment process continues at the leftmost block of the row below if any.

The rightmost block in each row has the additional cue which is a black dot indicating this is the end of row.

The rightmost block in the bottom row has an additional large black rectangle indicating this is the last block.

Figure [\ref=fig:OurScheme:MS1] shows an example of such barcode table. To verify that a table of barcodes are in the correct arrangement, User simply needs to verify the continuity of the counter, every but the last row ends with a small dot, and the last barcode ends with a big dot. It is easy to verify that by imposing the above rules, any insertion, deletion or rearrangement of the barcodes can be detected by visual inspection.

Alternative Methods

Besides using visual cues, there are other techniques to ensure that the barcodes are in correct order. This section compares our scheme with a few alternatives. In general, our scheme uses more pixels to carry the visual cue symbols. On the other hand, it has the following advantage: (1) It does not disrupt the user by requiring the user to scan all the barcodes. (2) It does not require the user to count the blocks on the terminal's display unit to verify the current block sequence on the mobile. (3) It allows the placement of barcodes to spread across different positions in a scrolling page, or even in different pages. A brief illustration of the alternative methods is given in Figure [\ref=fig:alternatives].

However, there are a few disadvantages of this method. Firstly, the scanning process could be less preferred when the user only want to browse a subset of the message (e.g. a user who wants to check a particular record from a list of transactions). Secondly, it is not easy to navigate using the relatively smaller display panel in the mobile device. Furthermore, it is not clear how to extend this method to the models where Mobile device is not trusted.

The advantage of this method is that it does not require the user to scan barcodes or verify visual cues, and the user can readily browse a sub-table of interest. While rearrangement attack can be prevented as the row and column information are encoded in the barcode, this method subjects to deletion attacks: the adversary may remove or duplicate an entire row of barcode without being detected. Although this could be patched by encoding more information (e.g. the total number of barcodes), the verification cost will increase (the user needs to count the barcode blocks).

Implementation

The useability of our proposed method can be improved using "augmented reality" as described in the introduction. We implemented a proof-of-concept system using webcam and laptop to simulate the mobile device.

We use OpenCV libraries [\cite=opencvWeb] for basic image processing operation and interfaces to the camera.

We use landmark-mapping [\cite=brown1992survey] method for image registration. That is, after Server generates the barcodes, it super-imposes a set of 2D points P called control points, whose position is known by Mobile, on the barcode image.

After Mobile captured a screenshot, it extracts the control points and find the best geometric transformation that maps the extracted control points to their original locations. In our implementation, we find the best linear transformation that matches the points. The transformation is then applied to the barcode image.

Performance

In this section we measure the performance of our proof-of-concept implementation in terms of error rate, frame rate and channel capacity.

Our camera is able to capture a region of around 20 blue points. Figure [\ref=fig:histogramofposoff] shows the histogram of the displacement of all the blue points on monitor 1. Note that the average displacement is less than 1 pixel. The image registration algorithm can be further refined by incorporating more effective and efficient known techniques.

After registration, we count the mismatches of superpixel between the registered image and the original image. 30 measurements are taken for each of the three display units. Figure [\ref=fig:errorrate] shows the error for each measurement.

Related Work

There is an extensive amount of literatures exploiting the camera as an additional visual channel for communication. Jacobs et al. [\cite=jacobs1996method] gave a method that establishes a channel from a controllable light source to a camera. McCune et al. proposed seeing-is-believing [\cite=mccune2009seeing], which carries out authentication and key-exchange over a visual channel established between a device's display and another device's camera. Wong et al. [\cite=wong2007multi] built a prototype on a Nokia Series 60 handphone that provides 46 bits for authentication over the visual channel.

Data can be transmitted to a camera effectively using 2D barcodes. There are many 2D barcode designs, for example, QR code [\cite=code2000international] and the High Capacity Color Barcode (HCCB) [\cite=parikh2008localization] that uses colored triangles. Many barcodes are designed to encode data in printed copies. There are also proposals that use other types of sources in the visual channel. Collomosse et al. proposed "Screen codes" [\cite=collomosse2008screen] for transferring data from a display to a camera-equipped mobile device, where the data are encoded as a grid of luminosity fluctuation within an arbitrary image. A challenging hurdle in using hand-held cameras to establish the channel is motion blur. A few stabilization algorithms are developed for handheld camera [\cite=sorel2005blind] [\cite=or2007hand], and for 2D barcodes [\cite=chu2007image].

Similar to our scheme, Costanza et al. [\cite=costanza2009designable] suggested a technique to embed designs into barcodes to increase the expressiveness and to bring visually meaning to them. These systems recognize the barcodes based on the topology, rather than geometry, of the codes [\cite=costanza2003region], and were initially developed for tracking objects in tangible user interfaces and augmented reality applications [\cite=costanza2003introducing]. Augmented reality has been exploited to enhance user experience on many applications including education [\cite=klopfer2008environmental], gaming [\cite=squire2007mad], outdoor activities [\cite=takacs2008outdoors]. Rekimoto et al. [\cite=rekimoto2000cybercode] Using 2D barcodes as the visual tags in the augmented reality environment, where a camera can capture the barcode on physical object and link them to their information.

Conclusion

In this paper, we investigated how visual channel can be deployed to enhance security of the communication between server and user in various settings. We pointed out that although authentication of an individual barcode can be easily carried out, the interesting technical challenge is in the verification of the relationships among several barcodes. This leads us to look into the problem of "subregion authentication" where a user wants to verify selective small pieces of data within a large dataset. Although there are a few methods to overcome the problem, they introduce disruptions during the interactive session and are thus less user-friendly. To achieve seamless interactions, we proposed using visual cue to bind location information to the barcode, so as to aid the user in visually verifying the data.

Our protocols demonstrated that, the visual channel "enhanced" with the visual cue, together with the mobile device's input/output device, jointly provide more flexibility in designing secure protocols. Viewing from another perspective, our investigation highlights limitations of visual channel, for instance, the observation that confidentiality is difficult to achieve under the setting where either the mobile device or the terminal could be dishonest. Our solution serves as an interesting example where security is achieved by coupling computer's processing power with human perceptual system. The design of our barcode also serves as an interesting application of fragile watermark.

To demonstrate the concept, we give a system that simulates the mobile device using webcam and laptop. The performance of the system is promising. Although we have not yet implemented the framework on actual mobile device, we believe that the processing power of many current mobile devices is sufficient to provide seamless interactions.