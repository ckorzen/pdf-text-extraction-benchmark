On the impact of explicit or semi-implicit integration methods over the stability of real-time numerical simulations

Introduction

Intricate physical and mathematical models for simulating soft or rigid bodies are the centre of intensive research efforts. Computer animation, laparoscopic haptic surgery simulations, graphical special effects or robotic manipulation are just a few of the fields where such models play a key role. The focus of our research is to address the issue of carrying out stable, physics-based simulations at interactive update rates. For this purpose, we have conceived an elementary framework for building deformable objects with soft or stiff constraints. Using this framework, we can test the efficiency and impact of several, well-known numerical integrators. To address our goal, we look find an equilibrium between an integrator's computational overhead, its precision, symplecticity and, most importantly, its inherent stability.

Following the aforementioned goals, we present a short literature survey on the numerical simulation of soft or semi-rigid bodies in section [\ref=sec:related_work_CC]. The mathematical apparatus for creating and simulating constrained objects is explained in section [\ref=sec:constrained_animation_CC], and our own, deformable linear object model case study is presented in section [\ref=sec:dlo_CC]. We present a general update strategy that supports any type of explicit or semi-implicit integration method in section [\ref=sec:simulation_CC]. Finally, the efficiency of several popular integrators is analysed and discussed in section [\ref=sec:results_CC], and we conclude this research in section [\ref=sec:conclusion_CC].

Related work

Stability as a central attribute to Physics-based object simulation within the Computer Graphics world was addressed by directly consider inherently stable integrators. The most popular method employed is the first order, implicit Euler scheme. Servin et al. [\cite=Servin151856] treated infinitely stiff springs as kinematic constraints and developed a system capable of simulating elastic behaviour at the cost of solving a large sparse linear system for each iteration. The hybrid method of Schroeder et al. [\cite=journals/cgf/SchroederKZF11] uses explicit updates for the elastic forces and implicit strategies for other components. This complex idea tries to reduce the effect of suppressing material vibrations due to the use of pure implicit integrators. By alternating between implicit, semi-implicit and explicit methods, Volino et al. [\cite=Volino2005] demonstrated how different cloth materials can be modeled to overcome the inabilities of one integrator to support a certain material property. Some object models allow using for computing an analytical force approximation for an implicit solver as demonstrated by Mesit et al. [\cite=journals/jcp/MesitGC07]. Their method of simulating gas filled soft bodies can thus easily support any integrator, but it relies on the topological structure for all analytical derivations. Finally, structured mass-spring models using pure implicit integrators were popularized by Baraf and Witkin [\cite=Baraff:1998:LSC:280814.280821] in their seminal paper on stable cloth simulation and by Desbrun et al. [\cite=Desbrun:1999:IAS:351631.351638] where inverse dynamics were used to tackle outstretching artefacts. For a discussion of the performance of some popular implicit solvers we direct the user to the paper of Hauth et al. [\cite=journals/cgf/HauthE01].

Explicit methods are more popular due to their reduced complexity. Finite element simulations using explicit integrators were performed by Fierz et al. [\cite=eth_biwi_00802]. To stabilize the numerical process, the authors proposed modifying the stiffness matrices of ill-conditioned tetrahedral elements. This allowed their simulation to use higher time steps in spite of the explicit updates. Although less computationally demanding and stable than their implicit counterparts, explicit integrators can share a fair amount of stability, energy conserving capabilities and time reversibility. In this respect, Tsai et al. [\cite=TSAI2004] present a comprehensive survey on symplectic integrators used in molecular dynamics.

In a different class of their own, position-based dynamics (see Bender et al. [\cite=BMOT2013] for a survey) offer a workaround for any force or impulse based system, avoiding the intricacies of using integrators. This family of methods is, however, inaccurate for scenarios where velocities and forces need to be measured, hence we mention it as an alternative for special effects applications.

For a comprehensive list of simulation methods involving deformable objects, we invite the reader to consult the work of Nealen et al. [\cite=CGF:CGF1000] or that of Jimenez [\cite=Jimenez2012].

Constrained object animation

To better understand the elements involved in most physics-based animation scenarios, we will briefly introduce a simple constraint enforcing system. Supporting this kind of simulation mechanism requires a discrete geometrical sampling of the initial shape of the object. For exemplification purposes, we consider a deformable linear object, embedded in a 3D space, whose cross-section is considerably smaller than its length. Its elastic properties that determine how its discrete structure changes are implemented by adding geometric constraints enforced by potentials (see the work of Teschner et al. [\cite=Teschner2004] for a more detailed and generalized application). These potentials provide a direct measure of how the structure of points differs from its initial configuration.

Generally, if [formula] are the vertices of a constrained group, then a constraint function is defined as follows:

[formula]

This function incorporates additional information relating the current vertex configuration of the group to the initial geometrical image through specific scalar measures of length, area, angle, volume, etc. For example, a length based constraint incorporates the initial or rest lengths of directly connected vertices as a reference for the measure of deviation. Generally, an energy function produces only positive amounts and can be written as:

[formula]

For a [formula] configuration, we now consider the restriction of the energy function at a node [formula]. This function is written as:

[formula]

Since the gradient vector coincides with the direction of maximum potential increase, it is natural to consider a penalty function that points in the opposite direction:

[formula]

This last equation can be written in an equivalent form:

[formula]

The simplest example of such a behaviour is the case of a linear spring connecting two points [formula] and [formula]. The natural constraint function is defined as:

[formula]

where L0 denotes the spring's rest length. From this constraint function, a corresponding elastic deformation potential energy can be expressed as:

[formula]

We define the following operator:

[formula]

also known in some works as the variational or functional derivative operator.

An elastic spring force at node [formula] can be derived using equation [\ref=eq:elastic_energy_CC]:

[formula]

After applying several derivative computation rules (chain rule and the derivative of a product of two functions), we find the general elastic force expression:

[formula]

where [formula] is the linear spring's stiffness coefficient.

A deformable object defined as a closed surface can be discretized by dividing its interior volume into tetrahedral cells. Apart from linear springs, it is desirable to enforce local constraints aimed at preserving the volumes under deformation. Such forces are easy to introduce by deriving them from a volume preserving constraint function involving tetrahedral cells:

[formula]

where V0 is the volume of the tetrahedron in its rest configuration. Subsequently, the volume preserving potential is:

[formula]

Using the same method as for linear springs, we compute the force at the [formula] vertex by using the [formula] operator:

[formula]

After conveniently arranging the results from the derivation of equation ([\ref=eq:volume_force_CC]), we can write down the expanded formula of this force:

[formula]

where KV is an added-in stiffness coefficient. Examining figure [\ref=fig:dlo_volumetric_force_CC], we can see how the volumetric force acts to prevent volume changes. For example, if point [formula] is shifted and the volume increases as a consequence, the direction of the volumetric force is given by the cross product vector [formula]. Inconsistent or "flipped" cell configurations, as well as degenerate tetrahedra can and are likely to be encountered during a simulation. Compressible bodies prevent themselves from being completely flattened by acting as non-linear spring elements. When their state is close to a collapse, the elastic forces should increase asymptotically towards infinity. Since the volumetric force component acts like a vertex to face spring in our system, we add a non-linear spring component, as suggested in [\cite=Cooper97]. Hence, if V is the current volume of a [formula] tetrahedron, then we can write the expression of the improved volumetric force as:

[formula]

where σ(x) is the sign function defined on the set of real values.

Another scenario that can prevent the simulation from recovering its initial rest shape in the absence of perturbing forces is the inversion phenomenon. The authors of [\cite=Schmedding2008] present an improved mechanism, capable of handling the inversion of a tetrahedral structure for finite element simulations. This process relies on finding a rotation that best aligns the deformed cell with its undeformed counterpart and then deriving penalty forces. While we could have used a similar approach, the above modification works for cases where negative volumes are reported. The elastic penalty forces described by equation ([\ref=eq:nonlinear_volumetric_force_CC]) are capable of acting against the inversion. Additionally, other constraint-based forces can be derived (e.g. area preserving forces for the triangular faces of a tetrahedron or angle preserving forces).

Deformable linear object model

Using constrained mass point configuration, we can now describe the steps required to build a tetrahedral cell-based deformable object along the geometric image of a support curve:

A curve discretization: [formula] where [formula] is a sample 3D point.

A set of frames: define the orientation vectors [formula], and [formula]. At each point [formula], a coordinate frame [formula] is attached.

Volumetric cells: for each pair of neighbouring vertices, [formula], three tetrahedra are constructed: (Rk + 1PkQkRk), (Rk + 1Qk + 1QkPk), and (Rk + 1PkPk + 1Qk + 1) (as depicted in figure [\ref=fig:dlo_tets_CC] ).

The tetrahedral cells allow retrieving consistent information about local torsion and curvature changes from one link to another adjacent segment. A direct reference for how the object twists around the RkRk + 1 line is given by the relative orientation of [formula] to [formula]. Structural resistance is added by substituting the edges of the tetrahedra with linear springs. These constraints tend to act like curvature springs since they oppose the bending of the object around the RkQk line.

To account for plausible twisting behaviour, we introduce a quaternion based constraint system that acts like a torsional spring at each Rk node of the object. Considering there are three connected nodes, Ri,Rj and Rk, in this order, the torsional spring tends to reposition the Qj point such that the resulting configuration is closer to the initial, rest configuration. Such a process requires finding a suitable axis and computing the relative orientation of the [formula] vector with respect to the [formula] and [formula] vectors. We achieve this behaviour by computing a torsion compensating quaternion:

[formula]

where [formula], [formula]. The angle [formula] represents the angle between the [formula] and [formula] vectors with respect to the [formula] axis , and the (0) superscript designates values for the initial, undeformed state of the object. The torsion quaternion, [formula] can then be used to rotate the [formula] vector to minimize the torsion offset. Instead of directly rotating this vector, a force will be applied to the Qj node, thus mimicking the effects of an angular spring. Figure [\ref=fig:dlo_quat_CC] depicts how the torsion quaternions are derived with respect to local geometry.

Simulation update logic

In general, the steps required for a complete update of the object's state can be assembled as follows:

Numerical integration: compute the current acceleration [formula] from the current state [formula], and add any force contributions from the collision solver stage. Using an explicit integration method, the new [formula] state is computed.

Approximate forces: [formula]. These values are to be used in the collision response stage.

Correct positions: applying a position based dynamics constraint projection, the linear springs are additionally relaxed. Such a process is equivalent to an iterative Gauss-Seidel solver and it requires translating the object vertices by small displacements. This step helps satisfying stiff constraints and avoids outstretching artifacts.

Collision resolution: pairwise link collisions are detected and response forces and impulses are derived. The positions [formula] and velocities [formula] are corrected, storing response forces in accumulators, Δf. These force residues are fed back to the numerical integration scheme and are included in the acceleration component the next iteration will use.

These steps must then be performed in this order, leading to a plausible update effect at interactive frame-rates.

Results

We have used our model to simulate a simple laparoscopic suturing task. Given a physical substrate, a thread was driven through a tissue-like structure (see figure [\ref=fig:suture]). The wire model we used is ideal for testing the behaviour of an integrator where both stiff and soft constraints drive the simulation. A simple methodology was employed to compute a score sheet for each integration scheme. We tracked the speed and stability of several methods while varying the time-step. The results were quantized by considering the explicit Euler method as a reference. The order of accuracy is not particularly important as it is orthogonal to our stability goals. Due to their energy-conserving properties, symplectic integrators are favoured when competing with other methods that achieve similar scores.

Analyzing table [\ref=tab:benchmark_CC], the symplectic Euler method (discussed by Cromer [\cite=cromer:455]) is the most stable for the total iteration time it needs (the score is obtained as the ratio between the maximum time step and the time needed to execute one simulation iteration). We modified the Midpoint method to achieve symplecticity, obtaining the second highest score. Given the fact that the Midpoint family of methods is accurate to the second order for the position terms (while being a first order method for the velocity terms), we recommend it for applications where accuracy is of some importance. The Verlet method ( [\cite=Verlet67] ), popular for molecular dynamics simulations, also benefits from its relatively high stability, symplecticity and second order accuracy. A third order method, the Forest-Ruth integration scheme [\cite=Forest:1990:FSI:84986.84996], represents the best alternative for applications where accuracy is a key element. The Runge-Kutta fourth order method, although supporting relatively high time steps, is the most time consuming and probably not a good choice for real time applications.

Although symplectic integrators excel in scenarios where their energy preserving features are central (e.g. where only conservative forces are involved), we have found this family of integrators to outperform their explicit integrator counterparts. As a last remark, we have also modified the Half Step method ([\cite=Hairer:1993:SOD:153158]) to support a semi-implicit update for the middle estimation [formula]. This modification significantly increases the method's stability, as seen in table [\ref=tab:benchmark_CC].

As an additional benchmark study, we have used the pendulum equation, [formula]. The explicit Euler is clearly the most unstable, introducing ghost energies as seen in the phase space diagram comparison with respect to the midpoint method in figure [\ref=fig:ee_mp_CC]. On the other hand, in figure [\ref=fig:sm_se_CC], the symplectic Euler and Midpoint methods have a much higher stability range, with the latter yielding slightly lower energy variations. As second order explicit integrators, the modified half step method is also more stable than the original version (as depicted in figure [\ref=fig:hs_mhs_CC]). Nevertheless, both methods tend to add ghost energies, but are much more stable than the first order explicit Euler. As the order of accuracy increases, larger time steps can be used (as it is the case with Runge-Kutta methods), but the performance impact does not justify such a trade-off. Finally, for models where no damping or non-conservative forces are involved, the Forest-Ruth and Verlet methods are the natural choices (comparative phase space plots in figure [\ref=fig:se_v_fr_CC]). Nevertheless, in case accuracy can be sacrificed, we still recommend using the first order symplectic Euler method as it has the highest stability versus complexity score.

Conclusion

In this work we have discussed the implications of employing an explicit integration method for updating a soft or semi-rigid body simulation. For real time applications where accuracy is not a goal, we recommend using a symplectic integrator as it has the best performance and stability score. Even when non-conservative forces are involved, this class of integrators is able to cope with stiff constraints. However, for applications where accuracy cannot be sacrificed, both the Runge-Kutta or the Forest-Ruth integrators can be used. The latter choice is accurate up to the third order and conserves energy, while the Runge-Kutta progressively loses small amounts of energy, counting for a slight increase in stability.

On a final note, implicit integrators, mentioned in the related work section [\ref=sec:related_work_CC], are not the usual choice for real time applications, thus motivating our investigation towards an explicit integrator alternative.

Explicit Integration Methods

In the following appendix, we present the minor modifications of the explicit integration methods that were tested in our simulation application. These numerical methods make use of an acceleration function, f, a fixed time-step, h, and compute new positions and velocities, given the previous state [formula].